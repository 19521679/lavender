{"ast":null,"code":"function Alignment(align, viewSize) {\n  var predefined = {\n    start: start,\n    center: center,\n    end: end\n  };\n\n  function start() {\n    return 0;\n  }\n\n  function center(n) {\n    return end(n) / 2;\n  }\n\n  function end(n) {\n    return viewSize - n;\n  }\n\n  function percent() {\n    return viewSize * Number(align);\n  }\n\n  function measure(n) {\n    if (typeof align === 'number') return percent();\n    return predefined[align](n);\n  }\n\n  var self = {\n    measure: measure\n  };\n  return self;\n}\n\nfunction Animation(callback) {\n  var animationFrame = 0;\n\n  function ifAnimating(active, cb) {\n    return function () {\n      if (active === !!animationFrame) cb();\n    };\n  }\n\n  function start() {\n    animationFrame = window.requestAnimationFrame(callback);\n  }\n\n  function stop() {\n    window.cancelAnimationFrame(animationFrame);\n    animationFrame = 0;\n  }\n\n  var self = {\n    proceed: ifAnimating(true, start),\n    start: ifAnimating(false, start),\n    stop: ifAnimating(true, stop)\n  };\n  return self;\n}\n\nfunction Axis(axis, contentDirection) {\n  var scroll = axis === 'y' ? 'y' : 'x';\n  var cross = axis === 'y' ? 'x' : 'y';\n  var startEdge = getStartEdge();\n  var endEdge = getEndEdge();\n\n  function measureSize(rect) {\n    var width = rect.width,\n        height = rect.height;\n    return scroll === 'x' ? width : height;\n  }\n\n  function getStartEdge() {\n    if (scroll === 'y') return 'top';\n    return contentDirection === 'rtl' ? 'right' : 'left';\n  }\n\n  function getEndEdge() {\n    if (scroll === 'y') return 'bottom';\n    return contentDirection === 'rtl' ? 'left' : 'right';\n  }\n\n  var self = {\n    scroll: scroll,\n    cross: cross,\n    startEdge: startEdge,\n    endEdge: endEdge,\n    measureSize: measureSize\n  };\n  return self;\n}\n\nfunction Limit(min, max) {\n  var length = Math.abs(min - max);\n\n  function reachedMin(n) {\n    return n < min;\n  }\n\n  function reachedMax(n) {\n    return n > max;\n  }\n\n  function reachedAny(n) {\n    return reachedMin(n) || reachedMax(n);\n  }\n\n  function constrain(n) {\n    if (!reachedAny(n)) return n;\n    return reachedMin(n) ? min : max;\n  }\n\n  function removeOffset(n) {\n    if (!length) return n;\n    return n - length * Math.ceil((n - max) / length);\n  }\n\n  var self = {\n    constrain: constrain,\n    length: length,\n    max: max,\n    min: min,\n    reachedAny: reachedAny,\n    reachedMax: reachedMax,\n    reachedMin: reachedMin,\n    removeOffset: removeOffset\n  };\n  return self;\n}\n\nfunction Counter(max, start, loop) {\n  var _a = Limit(0, max),\n      min = _a.min,\n      constrain = _a.constrain;\n\n  var loopEnd = max + 1;\n  var counter = withinLimit(start);\n\n  function withinLimit(n) {\n    return !loop ? constrain(n) : Math.abs((loopEnd + n) % loopEnd);\n  }\n\n  function get() {\n    return counter;\n  }\n\n  function set(n) {\n    counter = withinLimit(n);\n    return self;\n  }\n\n  function add(n) {\n    return set(get() + n);\n  }\n\n  function clone() {\n    return Counter(max, get(), loop);\n  }\n\n  var self = {\n    add: add,\n    clone: clone,\n    get: get,\n    set: set,\n    min: min,\n    max: max\n  };\n  return self;\n}\n\nfunction Direction(direction) {\n  var sign = direction === 'rtl' ? -1 : 1;\n\n  function applyTo(n) {\n    return n * sign;\n  }\n\n  var self = {\n    applyTo: applyTo\n  };\n  return self;\n}\n\nfunction EventStore() {\n  var listeners = [];\n\n  function add(node, type, handler, options) {\n    if (options === void 0) {\n      options = false;\n    }\n\n    node.addEventListener(type, handler, options);\n    listeners.push(function () {\n      return node.removeEventListener(type, handler, options);\n    });\n    return self;\n  }\n\n  function removeAll() {\n    listeners = listeners.filter(function (remove) {\n      return remove();\n    });\n    return self;\n  }\n\n  var self = {\n    add: add,\n    removeAll: removeAll\n  };\n  return self;\n}\n\nfunction Vector1D(value) {\n  var vector = value;\n\n  function get() {\n    return vector;\n  }\n\n  function set(n) {\n    vector = readNumber(n);\n    return self;\n  }\n\n  function add(n) {\n    vector += readNumber(n);\n    return self;\n  }\n\n  function subtract(n) {\n    vector -= readNumber(n);\n    return self;\n  }\n\n  function multiply(n) {\n    vector *= n;\n    return self;\n  }\n\n  function divide(n) {\n    vector /= n;\n    return self;\n  }\n\n  function normalize() {\n    if (vector !== 0) divide(vector);\n    return self;\n  }\n\n  function readNumber(n) {\n    return typeof n === 'number' ? n : n.get();\n  }\n\n  var self = {\n    add: add,\n    divide: divide,\n    get: get,\n    multiply: multiply,\n    normalize: normalize,\n    set: set,\n    subtract: subtract\n  };\n  return self;\n}\n\nfunction map(value, iStart, iStop, oStart, oStop) {\n  return oStart + (oStop - oStart) * ((value - iStart) / (iStop - iStart));\n}\n\nfunction mathSign(n) {\n  return !n ? 0 : n / Math.abs(n);\n}\n\nfunction deltaAbs(valueB, valueA) {\n  return Math.abs(valueB - valueA);\n}\n\nfunction factorAbs(valueB, valueA) {\n  if (valueB === 0 || valueA === 0) return 0;\n  if (Math.abs(valueB) <= Math.abs(valueA)) return 0;\n  var diff = deltaAbs(Math.abs(valueB), Math.abs(valueA));\n  return Math.abs(diff / valueB);\n}\n\nfunction roundToDecimals(decimalPoints) {\n  var pow = Math.pow(10, decimalPoints);\n  return function (n) {\n    return Math.round(n * pow) / pow;\n  };\n}\n\nfunction debounce(callback, time) {\n  var timeout = 0;\n  return function () {\n    window.clearTimeout(timeout);\n    timeout = window.setTimeout(callback, time) || 0;\n  };\n}\n\nfunction groupArray(array, size) {\n  var groups = [];\n\n  for (var i = 0; i < array.length; i += size) {\n    groups.push(array.slice(i, i + size));\n  }\n\n  return groups;\n}\n\nfunction arrayKeys(array) {\n  return Object.keys(array).map(Number);\n}\n\nfunction arrayLast(array) {\n  return array[lastIndex(array)];\n}\n\nfunction lastIndex(array) {\n  return Math.max(0, array.length - 1);\n}\n\nfunction DragHandler(axis, direction, rootNode, target, dragFree, dragTracker, location, animation, scrollTo, scrollBody, scrollTarget, index, events, loop, skipSnaps) {\n  var scrollAxis = axis.scroll,\n      crossAxis = axis.cross;\n  var focusNodes = ['INPUT', 'SELECT', 'TEXTAREA'];\n  var startScroll = Vector1D(0);\n  var startCross = Vector1D(0);\n  var dragStartPoint = Vector1D(0);\n  var activationEvents = EventStore();\n  var interactionEvents = EventStore();\n  var snapForceBoost = {\n    mouse: 2.5,\n    touch: 3.5\n  };\n  var freeForceBoost = {\n    mouse: 5,\n    touch: 7\n  };\n  var baseSpeed = dragFree ? 5 : 16;\n  var baseMass = 1;\n  var dragThreshold = 20;\n  var pointerIsDown = false;\n  var preventScroll = false;\n  var preventClick = false;\n  var isMouse = false;\n\n  function addActivationEvents() {\n    var node = rootNode;\n    activationEvents.add(node, 'touchmove', function () {\n      return undefined;\n    }).add(node, 'touchend', function () {\n      return undefined;\n    }).add(node, 'touchstart', down).add(node, 'mousedown', down).add(node, 'touchcancel', up).add(node, 'contextmenu', up).add(node, 'click', click);\n  }\n\n  function addInteractionEvents() {\n    var node = !isMouse ? rootNode : document;\n    interactionEvents.add(node, 'touchmove', move).add(node, 'touchend', up).add(node, 'mousemove', move).add(node, 'mouseup', up);\n  }\n\n  function removeAllEvents() {\n    activationEvents.removeAll();\n    interactionEvents.removeAll();\n  }\n\n  function isFocusNode(node) {\n    var name = node.nodeName || '';\n    return focusNodes.indexOf(name) > -1;\n  }\n\n  function forceBoost() {\n    var boost = dragFree ? freeForceBoost : snapForceBoost;\n    var type = isMouse ? 'mouse' : 'touch';\n    return boost[type];\n  }\n\n  function allowedForce(force, targetChanged) {\n    var next = index.clone().add(mathSign(force) * -1);\n    var isEdge = next.get() === index.min || next.get() === index.max;\n    var baseForce = scrollTarget.byDistance(force, !dragFree).distance;\n    if (dragFree || Math.abs(force) < dragThreshold) return baseForce;\n    if (!loop && isEdge) return baseForce * 0.6;\n    if (skipSnaps && targetChanged) return baseForce * 0.5;\n    return scrollTarget.byIndex(next.get(), 0).distance;\n  }\n\n  function down(evt) {\n    isMouse = evt.type === 'mousedown';\n    if (isMouse && evt.button !== 0) return;\n    var isMoving = deltaAbs(target.get(), location.get()) >= 2;\n    var clearPreventClick = isMouse || !isMoving;\n    var isNotFocusNode = !isFocusNode(evt.target);\n    var preventDefault = isMoving || isMouse && isNotFocusNode;\n    pointerIsDown = true;\n    dragTracker.pointerDown(evt);\n    dragStartPoint.set(target);\n    target.set(location);\n    scrollBody.useBaseMass().useSpeed(80);\n    addInteractionEvents();\n    startScroll.set(dragTracker.readPoint(evt, scrollAxis));\n    startCross.set(dragTracker.readPoint(evt, crossAxis));\n    events.emit('pointerDown');\n    if (clearPreventClick) preventClick = false;\n    if (preventDefault) evt.preventDefault();\n  }\n\n  function move(evt) {\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up();\n      var moveScroll = dragTracker.readPoint(evt, scrollAxis).get();\n      var moveCross = dragTracker.readPoint(evt, crossAxis).get();\n      var diffScroll = deltaAbs(moveScroll, startScroll.get());\n      var diffCross = deltaAbs(moveCross, startCross.get());\n      preventScroll = diffScroll > diffCross;\n      if (!preventScroll && !preventClick) return up();\n    }\n\n    var diff = dragTracker.pointerMove(evt);\n    if (!preventClick && diff) preventClick = true;\n    animation.start();\n    target.add(direction.applyTo(diff));\n    evt.preventDefault();\n  }\n\n  function up() {\n    var currentLocation = scrollTarget.byDistance(0, false);\n    var targetChanged = currentLocation.index !== index.get();\n    var rawForce = dragTracker.pointerUp() * forceBoost();\n    var force = allowedForce(direction.applyTo(rawForce), targetChanged);\n    var forceFactor = factorAbs(rawForce, force);\n    var isMoving = deltaAbs(target.get(), dragStartPoint.get()) >= 0.5;\n    var isVigorous = targetChanged && forceFactor > 0.75;\n    var isBelowThreshold = Math.abs(rawForce) < dragThreshold;\n    var speed = isVigorous ? 10 : baseSpeed;\n    var mass = isVigorous ? baseMass + 2.5 * forceFactor : baseMass;\n    if (isMoving && !isMouse) preventClick = true;\n    preventScroll = false;\n    pointerIsDown = false;\n    interactionEvents.removeAll();\n    scrollBody.useSpeed(isBelowThreshold ? 9 : speed).useMass(mass);\n    scrollTo.distance(force, !dragFree);\n    isMouse = false;\n    events.emit('pointerUp');\n  }\n\n  function click(evt) {\n    if (preventClick) evt.preventDefault();\n  }\n\n  function clickAllowed() {\n    return !preventClick;\n  }\n\n  function pointerDown() {\n    return pointerIsDown;\n  }\n\n  var self = {\n    addActivationEvents: addActivationEvents,\n    clickAllowed: clickAllowed,\n    pointerDown: pointerDown,\n    removeAllEvents: removeAllEvents\n  };\n  return self;\n}\n\nfunction DragTracker(axis, pxToPercent) {\n  var scrollAxis = axis.scroll;\n  var coords = {\n    x: 'clientX',\n    y: 'clientY'\n  };\n  var startDrag = Vector1D(0);\n  var diffDrag = Vector1D(0);\n  var lastDrag = Vector1D(0);\n  var pointValue = Vector1D(0);\n  var trackInterval = 10;\n  var trackLength = 5;\n  var trackTime = 100;\n  var trackPoints = [];\n  var lastMoveTime = new Date().getTime();\n  var isMouse = false;\n\n  function readPoint(evt, type) {\n    isMouse = !evt.touches;\n    var c = coords[type];\n    var value = isMouse ? evt[c] : evt.touches[0][c];\n    return pointValue.set(value);\n  }\n\n  function pointerDown(evt) {\n    var point = readPoint(evt, scrollAxis);\n    startDrag.set(point);\n    lastDrag.set(point);\n    return pxToPercent.measure(startDrag.get());\n  }\n\n  function pointerMove(evt) {\n    var point = readPoint(evt, scrollAxis);\n    var nowTime = new Date().getTime();\n    var diffTime = nowTime - lastMoveTime;\n\n    if (diffTime >= trackInterval) {\n      if (diffTime >= trackTime) trackPoints = [];\n      trackPoints.push(point.get());\n      lastMoveTime = nowTime;\n    }\n\n    diffDrag.set(point).subtract(lastDrag);\n    lastDrag.set(point);\n    return pxToPercent.measure(diffDrag.get());\n  }\n\n  function pointerUp() {\n    var nowTime = new Date().getTime();\n    var diffTime = nowTime - lastMoveTime;\n    var currentPoint = lastDrag.get();\n    var force = trackPoints.slice(-trackLength).map(function (trackPoint) {\n      return currentPoint - trackPoint;\n    }).sort(function (p1, p2) {\n      return Math.abs(p1) < Math.abs(p2) ? 1 : -1;\n    })[0];\n    lastDrag.set(diffTime > trackTime || !force ? 0 : force);\n    trackPoints = [];\n    return pxToPercent.measure(lastDrag.get());\n  }\n\n  var self = {\n    pointerDown: pointerDown,\n    pointerMove: pointerMove,\n    pointerUp: pointerUp,\n    readPoint: readPoint\n  };\n  return self;\n}\n\nfunction PxToPercent(viewInPx) {\n  var totalPercent = 100;\n\n  function measure(n) {\n    if (viewInPx === 0) return 0;\n    return n / viewInPx * totalPercent;\n  }\n\n  var self = {\n    measure: measure,\n    totalPercent: totalPercent\n  };\n  return self;\n}\n\nfunction ScrollBody(location, baseSpeed, baseMass) {\n  var roundToTwoDecimals = roundToDecimals(2);\n  var velocity = Vector1D(0);\n  var acceleration = Vector1D(0);\n  var attraction = Vector1D(0);\n  var attractionDirection = 0;\n  var speed = baseSpeed;\n  var mass = baseMass;\n\n  function update() {\n    velocity.add(acceleration);\n    location.add(velocity);\n    acceleration.multiply(0);\n  }\n\n  function applyForce(force) {\n    force.divide(mass);\n    acceleration.add(force);\n  }\n\n  function seek(target) {\n    attraction.set(target).subtract(location);\n    var magnitude = map(attraction.get(), 0, 100, 0, speed);\n    attractionDirection = mathSign(attraction.get());\n    attraction.normalize().multiply(magnitude).subtract(velocity);\n    applyForce(attraction);\n    return self;\n  }\n\n  function settle(target) {\n    var diff = target.get() - location.get();\n    var hasSettled = !roundToTwoDecimals(diff);\n    if (hasSettled) location.set(target);\n    return hasSettled;\n  }\n\n  function direction() {\n    return attractionDirection;\n  }\n\n  function useBaseSpeed() {\n    return useSpeed(baseSpeed);\n  }\n\n  function useBaseMass() {\n    return useMass(baseMass);\n  }\n\n  function useSpeed(n) {\n    speed = n;\n    return self;\n  }\n\n  function useMass(n) {\n    mass = n;\n    return self;\n  }\n\n  var self = {\n    direction: direction,\n    seek: seek,\n    settle: settle,\n    update: update,\n    useBaseMass: useBaseMass,\n    useBaseSpeed: useBaseSpeed,\n    useMass: useMass,\n    useSpeed: useSpeed\n  };\n  return self;\n}\n\nfunction ScrollBounds(limit, location, target, scrollBody) {\n  var pullBackThreshold = 10;\n  var disabled = false;\n\n  function shouldConstrain() {\n    if (disabled) return false;\n    if (!limit.reachedAny(target.get())) return false;\n    if (!limit.reachedAny(location.get())) return false;\n    return true;\n  }\n\n  function constrain(pointerDown) {\n    if (!shouldConstrain()) return;\n    var friction = pointerDown ? 0.7 : 0.45;\n    var diffToTarget = target.get() - location.get();\n    target.subtract(diffToTarget * friction);\n\n    if (!pointerDown && Math.abs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()));\n      scrollBody.useSpeed(10).useMass(3);\n    }\n  }\n\n  function toggleActive(active) {\n    disabled = !active;\n  }\n\n  var self = {\n    constrain: constrain,\n    toggleActive: toggleActive\n  };\n  return self;\n}\n\nfunction ScrollContain(viewSize, contentSize, snaps, snapsAligned, containScroll) {\n  var scrollBounds = Limit(-contentSize + viewSize, snaps[0]);\n  var snapsBounded = snapsAligned.map(scrollBounds.constrain);\n  var snapsContained = measureContained();\n\n  function findDuplicates() {\n    var startSnap = snapsBounded[0];\n    var endSnap = arrayLast(snapsBounded);\n    var min = snapsBounded.lastIndexOf(startSnap);\n    var max = snapsBounded.indexOf(endSnap) + 1;\n    return Limit(min, max);\n  }\n\n  function measureContained() {\n    if (contentSize <= viewSize) return [scrollBounds.max];\n    if (containScroll === 'keepSnaps') return snapsBounded;\n\n    var _a = findDuplicates(),\n        min = _a.min,\n        max = _a.max;\n\n    return snapsBounded.slice(min, max);\n  }\n\n  var self = {\n    snapsContained: snapsContained\n  };\n  return self;\n}\n\nfunction ScrollLimit(contentSize, scrollSnaps, loop) {\n  var limit = measureLimit();\n\n  function measureLimit() {\n    var startSnap = scrollSnaps[0];\n    var endSnap = arrayLast(scrollSnaps);\n    var min = loop ? startSnap - contentSize : endSnap;\n    var max = startSnap;\n    return Limit(min, max);\n  }\n\n  var self = {\n    limit: limit\n  };\n  return self;\n}\n\nfunction ScrollLooper(contentSize, pxToPercent, limit, location, vectors) {\n  var min = limit.min + pxToPercent.measure(0.1);\n  var max = limit.max + pxToPercent.measure(0.1);\n\n  var _a = Limit(min, max),\n      reachedMin = _a.reachedMin,\n      reachedMax = _a.reachedMax;\n\n  function shouldLoop(direction) {\n    if (direction === 1) return reachedMax(location.get());\n    if (direction === -1) return reachedMin(location.get());\n    return false;\n  }\n\n  function loop(direction) {\n    if (!shouldLoop(direction)) return;\n    var loopDistance = contentSize * (direction * -1);\n    vectors.forEach(function (v) {\n      return v.add(loopDistance);\n    });\n  }\n\n  var self = {\n    loop: loop\n  };\n  return self;\n}\n\nfunction ScrollProgress(limit) {\n  var max = limit.max,\n      scrollLength = limit.length;\n\n  function get(n) {\n    var currentLocation = n - max;\n    return currentLocation / -scrollLength;\n  }\n\n  var self = {\n    get: get\n  };\n  return self;\n}\n\nfunction ScrollSnap(axis, alignment, pxToPercent, containerRect, slideRects, slidesToScroll) {\n  var startEdge = axis.startEdge,\n      endEdge = axis.endEdge;\n  var snaps = measureUnaligned();\n  var snapsAligned = measureAligned();\n\n  function measureSizes() {\n    return groupArray(slideRects, slidesToScroll).map(function (rects) {\n      return arrayLast(rects)[endEdge] - rects[0][startEdge];\n    }).map(pxToPercent.measure).map(Math.abs);\n  }\n\n  function measureUnaligned() {\n    return slideRects.map(function (rect) {\n      return containerRect[startEdge] - rect[startEdge];\n    }).map(pxToPercent.measure).map(function (snap) {\n      return -Math.abs(snap);\n    });\n  }\n\n  function measureAligned() {\n    var groupedSnaps = groupArray(snaps, slidesToScroll).map(function (g) {\n      return g[0];\n    });\n    var alignments = measureSizes().map(alignment.measure);\n    return groupedSnaps.map(function (snap, index) {\n      return snap + alignments[index];\n    });\n  }\n\n  var self = {\n    snaps: snaps,\n    snapsAligned: snapsAligned\n  };\n  return self;\n}\n\nfunction ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {\n  var reachedAny = limit.reachedAny,\n      removeOffset = limit.removeOffset,\n      constrain = limit.constrain;\n\n  function minDistance(d1, d2) {\n    return Math.abs(d1) < Math.abs(d2) ? d1 : d2;\n  }\n\n  function findTargetSnap(target) {\n    var distance = loop ? removeOffset(target) : constrain(target);\n    var ascDiffsToSnaps = scrollSnaps.map(function (scrollSnap) {\n      return scrollSnap - distance;\n    }).map(function (diffToSnap) {\n      return shortcut(diffToSnap, 0);\n    }).map(function (diff, i) {\n      return {\n        diff: diff,\n        index: i\n      };\n    }).sort(function (d1, d2) {\n      return Math.abs(d1.diff) - Math.abs(d2.diff);\n    });\n    var index = ascDiffsToSnaps[0].index;\n    return {\n      index: index,\n      distance: distance\n    };\n  }\n\n  function shortcut(target, direction) {\n    var t1 = target;\n    var t2 = target + contentSize;\n    var t3 = target - contentSize;\n    if (!loop) return t1;\n    if (!direction) return minDistance(minDistance(t1, t2), t3);\n    var shortest = minDistance(t1, direction === 1 ? t2 : t3);\n    return Math.abs(shortest) * direction;\n  }\n\n  function byIndex(index, direction) {\n    var diffToSnap = scrollSnaps[index] - targetVector.get();\n    var distance = shortcut(diffToSnap, direction);\n    return {\n      index: index,\n      distance: distance\n    };\n  }\n\n  function byDistance(distance, snap) {\n    var target = targetVector.get() + distance;\n\n    var _a = findTargetSnap(target),\n        index = _a.index,\n        targetSnapDistance = _a.distance;\n\n    var reachedBound = !loop && reachedAny(target);\n    if (!snap || reachedBound) return {\n      index: index,\n      distance: distance\n    };\n    var diffToSnap = scrollSnaps[index] - targetSnapDistance;\n    var snapDistance = distance + shortcut(diffToSnap, 0);\n    return {\n      index: index,\n      distance: snapDistance\n    };\n  }\n\n  var self = {\n    byDistance: byDistance,\n    byIndex: byIndex,\n    shortcut: shortcut\n  };\n  return self;\n}\n\nfunction ScrollTo(animation, indexCurrent, indexPrevious, scrollTarget, targetVector, events) {\n  function scrollTo(target) {\n    var distanceDiff = target.distance;\n    var indexDiff = target.index !== indexCurrent.get();\n\n    if (distanceDiff) {\n      animation.start();\n      targetVector.add(distanceDiff);\n    }\n\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get());\n      indexCurrent.set(target.index);\n      events.emit('select');\n    }\n  }\n\n  function distance(n, snap) {\n    var target = scrollTarget.byDistance(n, snap);\n    scrollTo(target);\n  }\n\n  function index(n, direction) {\n    var targetIndex = indexCurrent.clone().set(n);\n    var target = scrollTarget.byIndex(targetIndex.get(), direction);\n    scrollTo(target);\n  }\n\n  var self = {\n    distance: distance,\n    index: index\n  };\n  return self;\n}\n\nfunction SlideLooper(axis, viewSize, contentSize, slideSizesWithGaps, scrollSnaps, slidesInView, scrollLocation, slides) {\n  var ascItems = arrayKeys(slideSizesWithGaps);\n  var descItems = arrayKeys(slideSizesWithGaps).reverse();\n  var loopPoints = startPoints().concat(endPoints());\n\n  function removeSlideSizes(indexes, from) {\n    return indexes.reduce(function (a, i) {\n      return a - slideSizesWithGaps[i];\n    }, from);\n  }\n\n  function slidesInGap(indexes, gap) {\n    return indexes.reduce(function (a, i) {\n      var remainingGap = removeSlideSizes(a, gap);\n      return remainingGap > 0 ? a.concat([i]) : a;\n    }, []);\n  }\n\n  function findLoopPoints(indexes, edge) {\n    var isStartEdge = edge === 'start';\n    var offset = isStartEdge ? -contentSize : contentSize;\n    var slideBounds = slidesInView.findSlideBounds(offset);\n    return indexes.map(function (index) {\n      var initial = isStartEdge ? 0 : -contentSize;\n      var altered = isStartEdge ? contentSize : 0;\n      var bounds = slideBounds.filter(function (b) {\n        return b.index === index;\n      })[0];\n      var point = bounds[isStartEdge ? 'end' : 'start'];\n\n      var getTarget = function getTarget() {\n        return scrollLocation.get() > point ? initial : altered;\n      };\n\n      return {\n        point: point,\n        getTarget: getTarget,\n        index: index,\n        location: -1\n      };\n    });\n  }\n\n  function startPoints() {\n    var gap = scrollSnaps[0] - 1;\n    var indexes = slidesInGap(descItems, gap);\n    return findLoopPoints(indexes, 'end');\n  }\n\n  function endPoints() {\n    var gap = viewSize - scrollSnaps[0] - 1;\n    var indexes = slidesInGap(ascItems, gap);\n    return findLoopPoints(indexes, 'start');\n  }\n\n  function canLoop() {\n    return loopPoints.every(function (_a) {\n      var index = _a.index;\n      var otherIndexes = ascItems.filter(function (i) {\n        return i !== index;\n      });\n      return removeSlideSizes(otherIndexes, viewSize) <= 0;\n    });\n  }\n\n  function loop() {\n    loopPoints.forEach(function (loopPoint) {\n      var getTarget = loopPoint.getTarget,\n          location = loopPoint.location,\n          index = loopPoint.index;\n      var target = getTarget();\n\n      if (target !== location) {\n        slides[index].style[axis.startEdge] = target + \"%\";\n        loopPoint.location = target;\n      }\n    });\n  }\n\n  function clear() {\n    loopPoints.forEach(function (_a) {\n      var index = _a.index;\n      slides[index].style[axis.startEdge] = '';\n    });\n  }\n\n  var self = {\n    canLoop: canLoop,\n    clear: clear,\n    loop: loop,\n    loopPoints: loopPoints\n  };\n  return self;\n}\n\nfunction SlidesInView(viewSize, contentSize, slideSizes, snaps, loop, inViewThreshold) {\n  var threshold = Math.min(Math.max(inViewThreshold, 0.01), 0.99);\n  var offsets = loop ? [0, contentSize, -contentSize] : [0];\n  var slideBounds = offsets.reduce(function (a, offset) {\n    return a.concat(findSlideBounds(offset, threshold));\n  }, []);\n\n  function findSlideBounds(offset, threshold) {\n    var thresholds = slideSizes.map(function (s) {\n      return s * (threshold || 0);\n    });\n    return snaps.map(function (snap, index) {\n      return {\n        start: snap - slideSizes[index] + thresholds[index] + offset,\n        end: snap + viewSize - thresholds[index] + offset,\n        index: index\n      };\n    });\n  }\n\n  function check(location) {\n    return slideBounds.reduce(function (list, slideBound) {\n      var index = slideBound.index,\n          start = slideBound.start,\n          end = slideBound.end;\n      var inList = list.indexOf(index) !== -1;\n      var inView = start < location && end > location;\n      return !inList && inView ? list.concat([index]) : list;\n    }, []);\n  }\n\n  var self = {\n    check: check,\n    findSlideBounds: findSlideBounds\n  };\n  return self;\n}\n\nfunction SlideSizes(axis, pxToPercent, slides, slideRects, loop) {\n  var measureSize = axis.measureSize,\n      startEdge = axis.startEdge,\n      endEdge = axis.endEdge;\n  var sizesInPx = slideRects.map(measureSize);\n  var slideSizes = sizesInPx.map(pxToPercent.measure);\n  var slideSizesWithGaps = measureWithGaps();\n\n  function measureWithGaps() {\n    return slideRects.map(function (rect, index, rects) {\n      var isLast = index === lastIndex(rects);\n      var style = window.getComputedStyle(arrayLast(slides));\n      var endGap = parseFloat(style.getPropertyValue(\"margin-\" + endEdge));\n      if (isLast) return sizesInPx[index] + (loop ? endGap : 0);\n      return rects[index + 1][startEdge] - rect[startEdge];\n    }).map(pxToPercent.measure).map(Math.abs);\n  }\n\n  var self = {\n    slideSizes: slideSizes,\n    slideSizesWithGaps: slideSizesWithGaps\n  };\n  return self;\n}\n\nfunction Translate(axis, direction, container) {\n  var containerStyle = container.style;\n  var translate = axis.scroll === 'x' ? x : y;\n  var disabled = false;\n\n  function x(n) {\n    return \"translate3d(\" + n + \"%,0px,0px)\";\n  }\n\n  function y(n) {\n    return \"translate3d(0px,\" + n + \"%,0px)\";\n  }\n\n  function to(target) {\n    if (disabled) return;\n    containerStyle.transform = translate(direction.applyTo(target.get()));\n  }\n\n  function toggleActive(active) {\n    disabled = !active;\n  }\n\n  function clear() {\n    containerStyle.transform = '';\n  }\n\n  var self = {\n    clear: clear,\n    to: to,\n    toggleActive: toggleActive\n  };\n  return self;\n}\n\nfunction Engine(root, container, slides, options, events) {\n  // Options\n  var align = options.align,\n      scrollAxis = options.axis,\n      contentDirection = options.direction,\n      startIndex = options.startIndex,\n      inViewThreshold = options.inViewThreshold,\n      loop = options.loop,\n      speed = options.speed,\n      dragFree = options.dragFree,\n      slidesToScroll = options.slidesToScroll,\n      skipSnaps = options.skipSnaps,\n      containScroll = options.containScroll; // Measurements\n\n  var containerRect = container.getBoundingClientRect();\n  var slideRects = slides.map(function (slide) {\n    return slide.getBoundingClientRect();\n  });\n  var direction = Direction(contentDirection);\n  var axis = Axis(scrollAxis, contentDirection);\n  var pxToPercent = PxToPercent(axis.measureSize(containerRect));\n  var viewSize = pxToPercent.totalPercent;\n  var alignment = Alignment(align, viewSize);\n\n  var _a = SlideSizes(axis, pxToPercent, slides, slideRects, loop),\n      slideSizes = _a.slideSizes,\n      slideSizesWithGaps = _a.slideSizesWithGaps;\n\n  var _b = ScrollSnap(axis, alignment, pxToPercent, containerRect, slideRects, slidesToScroll),\n      snaps = _b.snaps,\n      snapsAligned = _b.snapsAligned;\n\n  var contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);\n  var snapsContained = ScrollContain(viewSize, contentSize, snaps, snapsAligned, containScroll).snapsContained;\n  var contain = !loop && containScroll !== '';\n  var scrollSnaps = contain ? snapsContained : snapsAligned;\n  var limit = ScrollLimit(contentSize, scrollSnaps, loop).limit; // Indexes\n\n  var index = Counter(lastIndex(scrollSnaps), startIndex, loop);\n  var indexPrevious = index.clone();\n  var slideIndexes = arrayKeys(slides); // Draw\n\n  var update = function update() {\n    if (!loop) engine.scrollBounds.constrain(engine.dragHandler.pointerDown());\n    engine.scrollBody.seek(target).update();\n    var settled = engine.scrollBody.settle(target);\n\n    if (settled && !engine.dragHandler.pointerDown()) {\n      engine.animation.stop();\n      events.emit('settle');\n    }\n\n    if (!settled) {\n      events.emit('scroll');\n    }\n\n    if (loop) {\n      engine.scrollLooper.loop(engine.scrollBody.direction());\n      engine.slideLooper.loop();\n    }\n\n    engine.translate.to(location);\n    engine.animation.proceed();\n  }; // Shared\n\n\n  var animation = Animation(update);\n  var startLocation = scrollSnaps[index.get()];\n  var location = Vector1D(startLocation);\n  var target = Vector1D(startLocation);\n  var scrollBody = ScrollBody(location, speed, 1);\n  var scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);\n  var scrollTo = ScrollTo(animation, index, indexPrevious, scrollTarget, target, events);\n  var slidesInView = SlidesInView(viewSize, contentSize, slideSizes, snaps, loop, inViewThreshold); // DragHandler\n\n  var dragHandler = DragHandler(axis, direction, root, target, dragFree, DragTracker(axis, pxToPercent), location, animation, scrollTo, scrollBody, scrollTarget, index, events, loop, skipSnaps); // Slider\n\n  var engine = {\n    animation: animation,\n    axis: axis,\n    direction: direction,\n    dragHandler: dragHandler,\n    eventStore: EventStore(),\n    pxToPercent: pxToPercent,\n    index: index,\n    indexPrevious: indexPrevious,\n    limit: limit,\n    location: location,\n    options: options,\n    scrollBody: scrollBody,\n    scrollBounds: ScrollBounds(limit, location, target, scrollBody),\n    scrollLooper: ScrollLooper(contentSize, pxToPercent, limit, location, [location, target]),\n    scrollProgress: ScrollProgress(limit),\n    scrollSnaps: scrollSnaps,\n    scrollTarget: scrollTarget,\n    scrollTo: scrollTo,\n    slideLooper: SlideLooper(axis, viewSize, contentSize, slideSizesWithGaps, scrollSnaps, slidesInView, location, slides),\n    slidesInView: slidesInView,\n    slideIndexes: slideIndexes,\n    target: target,\n    translate: Translate(axis, direction, container)\n  };\n  return engine;\n}\n\nfunction EventEmitter() {\n  var listeners = {};\n\n  function getListeners(evt) {\n    return listeners[evt] || [];\n  }\n\n  function emit(evt) {\n    getListeners(evt).forEach(function (e) {\n      return e(evt);\n    });\n    return self;\n  }\n\n  function on(evt, cb) {\n    listeners[evt] = getListeners(evt).concat([cb]);\n    return self;\n  }\n\n  function off(evt, cb) {\n    listeners[evt] = getListeners(evt).filter(function (e) {\n      return e !== cb;\n    });\n    return self;\n  }\n\n  var self = {\n    emit: emit,\n    off: off,\n    on: on\n  };\n  return self;\n}\n\nvar defaultOptions = {\n  align: 'center',\n  axis: 'x',\n  containScroll: '',\n  direction: 'ltr',\n  dragFree: false,\n  draggable: true,\n  inViewThreshold: 0,\n  loop: false,\n  skipSnaps: false,\n  slidesToScroll: 1,\n  speed: 10,\n  startIndex: 0\n};\n\nfunction OptionsPseudo(node) {\n  var pseudoString = getComputedStyle(node, ':before').content;\n\n  function get() {\n    try {\n      return JSON.parse(pseudoString.slice(1, -1).replace(/\\\\/g, ''));\n    } catch (error) {} // eslint-disable-line no-empty\n\n\n    return {};\n  }\n\n  var self = {\n    get: get\n  };\n  return self;\n}\n\nfunction EmblaCarousel(nodes, userOptions, userPlugins) {\n  var events = EventEmitter();\n  var debouncedResize = debounce(resize, 500);\n  var reInit = reActivate;\n  var on = events.on,\n      off = events.off;\n  var engine;\n  var activated = false;\n  var optionsBase = Object.assign({}, defaultOptions);\n  var options = Object.assign({}, optionsBase);\n  var optionsPseudo;\n  var plugins;\n  var rootSize = 0;\n  var root;\n  var container;\n  var slides;\n\n  function setupElements() {\n    var providedContainer = 'container' in nodes && nodes.container;\n    var providedSlides = 'slides' in nodes && nodes.slides;\n    root = 'root' in nodes ? nodes.root : nodes;\n    container = providedContainer || root.children[0];\n    slides = providedSlides || [].slice.call(container.children);\n    optionsPseudo = OptionsPseudo(root);\n  }\n\n  function activate(withOptions, withPlugins) {\n    setupElements();\n    optionsBase = Object.assign({}, optionsBase, withOptions);\n    options = Object.assign({}, optionsBase, optionsPseudo.get());\n    plugins = Object.assign([], withPlugins);\n    engine = Engine(root, container, slides, options, events);\n    engine.eventStore.add(window, 'resize', debouncedResize);\n    engine.translate.to(engine.location);\n    rootSize = engine.axis.measureSize(root.getBoundingClientRect());\n    plugins.forEach(function (plugin) {\n      return plugin.init(self);\n    });\n\n    if (options.loop) {\n      if (!engine.slideLooper.canLoop()) {\n        deActivate();\n        return activate({\n          loop: false\n        }, withPlugins);\n      }\n\n      engine.slideLooper.loop();\n    }\n\n    if (options.draggable && container.offsetParent && slides.length) {\n      engine.dragHandler.addActivationEvents();\n    }\n\n    if (!activated) {\n      setTimeout(function () {\n        return events.emit('init');\n      }, 0);\n      activated = true;\n    }\n  }\n\n  function reActivate(withOptions, withPlugins) {\n    if (!activated) return;\n    var startIndex = selectedScrollSnap();\n    var newOptions = Object.assign({\n      startIndex: startIndex\n    }, withOptions);\n    deActivate();\n    activate(newOptions, withPlugins || plugins);\n    events.emit('reInit');\n  }\n\n  function deActivate() {\n    engine.dragHandler.removeAllEvents();\n    engine.animation.stop();\n    engine.eventStore.removeAll();\n    engine.translate.clear();\n    engine.slideLooper.clear();\n    plugins.forEach(function (plugin) {\n      return plugin.destroy();\n    });\n  }\n\n  function destroy() {\n    if (!activated) return;\n    deActivate();\n    activated = false;\n    events.emit('destroy');\n  }\n\n  function resize() {\n    if (!activated) return;\n    var size = engine.axis.measureSize(root.getBoundingClientRect());\n    if (rootSize !== size) reActivate();\n    events.emit('resize');\n  }\n\n  function slidesInView(target) {\n    var location = engine[target ? 'target' : 'location'].get();\n    var type = options.loop ? 'removeOffset' : 'constrain';\n    return engine.slidesInView.check(engine.limit[type](location));\n  }\n\n  function slidesNotInView(target) {\n    var inView = slidesInView(target);\n    return engine.slideIndexes.filter(function (index) {\n      return inView.indexOf(index) === -1;\n    });\n  }\n\n  function scrollTo(index, jump, direction) {\n    engine.scrollBody.useBaseMass().useSpeed(jump ? 100 : options.speed);\n    if (activated) engine.scrollTo.index(index, direction || 0);\n  }\n\n  function scrollNext(jump) {\n    var next = engine.index.clone().add(1);\n    scrollTo(next.get(), jump === true, -1);\n  }\n\n  function scrollPrev(jump) {\n    var prev = engine.index.clone().add(-1);\n    scrollTo(prev.get(), jump === true, 1);\n  }\n\n  function canScrollNext() {\n    var next = engine.index.clone().add(1);\n    return next.get() !== selectedScrollSnap();\n  }\n\n  function canScrollPrev() {\n    var prev = engine.index.clone().add(-1);\n    return prev.get() !== selectedScrollSnap();\n  }\n\n  function scrollSnapList() {\n    return engine.scrollSnaps.map(engine.scrollProgress.get);\n  }\n\n  function scrollProgress() {\n    return engine.scrollProgress.get(engine.location.get());\n  }\n\n  function selectedScrollSnap() {\n    return engine.index.get();\n  }\n\n  function previousScrollSnap() {\n    return engine.indexPrevious.get();\n  }\n\n  function clickAllowed() {\n    return engine.dragHandler.clickAllowed();\n  }\n\n  function internalEngine() {\n    return engine;\n  }\n\n  function rootNode() {\n    return root;\n  }\n\n  function containerNode() {\n    return container;\n  }\n\n  function slideNodes() {\n    return slides;\n  }\n\n  var self = {\n    canScrollNext: canScrollNext,\n    canScrollPrev: canScrollPrev,\n    clickAllowed: clickAllowed,\n    containerNode: containerNode,\n    internalEngine: internalEngine,\n    destroy: destroy,\n    off: off,\n    on: on,\n    previousScrollSnap: previousScrollSnap,\n    reInit: reInit,\n    rootNode: rootNode,\n    scrollNext: scrollNext,\n    scrollPrev: scrollPrev,\n    scrollProgress: scrollProgress,\n    scrollSnapList: scrollSnapList,\n    scrollTo: scrollTo,\n    selectedScrollSnap: selectedScrollSnap,\n    slideNodes: slideNodes,\n    slidesInView: slidesInView,\n    slidesNotInView: slidesNotInView\n  };\n  activate(userOptions, userPlugins);\n  return self;\n}\n\nexport default EmblaCarousel;","map":{"version":3,"sources":["src/components/Alignment.ts","src/components/Animation.ts","src/components/Axis.ts","src/components/Limit.ts","src/components/Counter.ts","src/components/Direction.ts","src/components/EventStore.ts","src/components/Vector1d.ts","src/components/utils.ts","src/components/DragHandler.ts","src/components/DragTracker.ts","src/components/PxToPercent.ts","src/components/ScrollBody.ts","src/components/ScrollBounds.ts","src/components/ScrollContain.ts","src/components/ScrollLimit.ts","src/components/ScrollLooper.ts","src/components/ScrollProgress.ts","src/components/ScrollSnap.ts","src/components/ScrollTarget.ts","src/components/ScrollTo.ts","src/components/SlideLooper.ts","src/components/SlidesInView.ts","src/components/SlideSizes.ts","src/components/Translate.ts","src/components/Engine.ts","src/components/EventEmitter.ts","src/components/Options.ts","src/components/OptionsPseudo.ts","src/components/index.ts"],"names":["Alignment","align","viewSize","predefined","start","center","end","Number","percent","self","measure","Animation","callback","animationFrame","active","cb","window","proceed","ifAnimating","stop","Axis","axis","contentDirection","scroll","cross","startEdge","getStartEdge","endEdge","getEndEdge","height","rect","measureSize","Limit","min","max","length","Math","n","reachedMin","reachedMax","reachedAny","constrain","removeOffset","Counter","loop","loopEnd","counter","withinLimit","set","get","add","clone","Direction","direction","sign","applyTo","EventStore","listeners","node","removeAll","Vector1D","value","vector","readNumber","divide","multiply","normalize","subtract","map","iStart","iStop","oStart","oStop","mathSign","deltaAbs","valueB","valueA","factorAbs","diff","roundToDecimals","decimalPoints","pow","debounce","time","timeout","groupArray","array","size","groups","i","arrayKeys","Object","arrayLast","lastIndex","DragHandler","rootNode","target","dragFree","dragTracker","location","animation","scrollTo","scrollBody","scrollTarget","index","events","skipSnaps","scrollAxis","crossAxis","focusNodes","startScroll","startCross","dragStartPoint","activationEvents","interactionEvents","snapForceBoost","mouse","touch","freeForceBoost","baseSpeed","baseMass","dragThreshold","pointerIsDown","preventScroll","preventClick","isMouse","name","boost","type","next","isEdge","baseForce","evt","isMoving","clearPreventClick","isNotFocusNode","isFocusNode","preventDefault","addInteractionEvents","up","moveScroll","moveCross","diffScroll","diffCross","currentLocation","targetChanged","rawForce","forceBoost","force","allowedForce","forceFactor","isVigorous","isBelowThreshold","speed","mass","addActivationEvents","clickAllowed","pointerDown","removeAllEvents","DragTracker","pxToPercent","coords","x","y","startDrag","diffDrag","lastDrag","pointValue","trackInterval","trackLength","trackTime","trackPoints","lastMoveTime","c","point","readPoint","nowTime","diffTime","currentPoint","pointerMove","pointerUp","PxToPercent","viewInPx","totalPercent","ScrollBody","roundToTwoDecimals","velocity","acceleration","attraction","attractionDirection","magnitude","applyForce","hasSettled","useSpeed","useMass","seek","settle","update","useBaseMass","useBaseSpeed","ScrollBounds","limit","pullBackThreshold","disabled","shouldConstrain","friction","diffToTarget","toggleActive","ScrollContain","contentSize","snaps","snapsAligned","containScroll","scrollBounds","snapsBounded","snapsContained","measureContained","startSnap","endSnap","findDuplicates","ScrollLimit","scrollSnaps","measureLimit","ScrollLooper","vectors","shouldLoop","loopDistance","ScrollProgress","scrollLength","ScrollSnap","alignment","containerRect","slideRects","slidesToScroll","measureUnaligned","measureAligned","rects","groupedSnaps","alignments","measureSizes","ScrollTarget","targetVector","distance","ascDiffsToSnaps","d1","d2","t1","t2","t3","minDistance","shortest","diffToSnap","shortcut","targetSnapDistance","findTargetSnap","reachedBound","snapDistance","byDistance","byIndex","ScrollTo","indexCurrent","indexPrevious","distanceDiff","indexDiff","targetIndex","SlideLooper","slideSizesWithGaps","slidesInView","scrollLocation","slides","ascItems","descItems","loopPoints","startPoints","endPoints","a","remainingGap","removeSlideSizes","isStartEdge","edge","offset","slideBounds","initial","altered","bounds","getTarget","gap","indexes","slidesInGap","findLoopPoints","otherIndexes","loopPoint","canLoop","clear","SlidesInView","slideSizes","inViewThreshold","threshold","offsets","findSlideBounds","thresholds","snap","slideBound","inList","list","inView","check","SlideSizes","sizesInPx","measureWithGaps","isLast","style","endGap","parseFloat","Translate","container","containerStyle","translate","to","Engine","root","options","startIndex","contain","slideIndexes","engine","settled","startLocation","dragHandler","eventStore","scrollLooper","scrollProgress","slideLooper","EventEmitter","getListeners","emit","off","on","defaultOptions","draggable","OptionsPseudo","pseudoString","getComputedStyle","JSON","debouncedResize","reInit","activated","optionsBase","rootSize","providedContainer","nodes","providedSlides","optionsPseudo","setupElements","plugins","deActivate","activate","setTimeout","selectedScrollSnap","newOptions","withPlugins","reActivate","jump","prev","canScrollNext","canScrollPrev","containerNode","internalEngine","destroy","previousScrollSnap","scrollNext","scrollPrev","scrollSnapList","slideNodes","slidesNotInView"],"mappings":"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","sourcesContent":["export type AlignmentOptionType = 'start' | 'center' | 'end' | number\n\nexport type AlignmentType = {\n  measure: (n: number) => number\n}\n\nexport function Alignment(\n  align: AlignmentOptionType,\n  viewSize: number,\n): AlignmentType {\n  const predefined = { start, center, end }\n\n  function start(): number {\n    return 0\n  }\n\n  function center(n: number): number {\n    return end(n) / 2\n  }\n\n  function end(n: number): number {\n    return viewSize - n\n  }\n\n  function percent(): number {\n    return viewSize * Number(align)\n  }\n\n  function measure(n: number): number {\n    if (typeof align === 'number') return percent()\n    return predefined[align](n)\n  }\n\n  const self: AlignmentType = {\n    measure,\n  }\n  return self\n}\n","type CallbackType = () => void\n\nexport type AnimationType = {\n  start: () => void\n  stop: () => void\n  proceed: () => void\n}\n\nexport function Animation(callback: FrameRequestCallback): AnimationType {\n  let animationFrame = 0\n\n  function ifAnimating(active: boolean, cb: CallbackType): CallbackType {\n    return (): void => {\n      if (active === !!animationFrame) cb()\n    }\n  }\n\n  function start(): void {\n    animationFrame = window.requestAnimationFrame(callback)\n  }\n\n  function stop(): void {\n    window.cancelAnimationFrame(animationFrame)\n    animationFrame = 0\n  }\n\n  const self: AnimationType = {\n    proceed: ifAnimating(true, start),\n    start: ifAnimating(false, start),\n    stop: ifAnimating(true, stop),\n  }\n  return self\n}\n","import { DirectionOptionType } from './Direction'\n\nexport type AxisOptionType = 'x' | 'y'\ntype AxisEdgeType = 'top' | 'right' | 'bottom' | 'left'\n\nexport type AxisType = {\n  scroll: AxisOptionType\n  cross: AxisOptionType\n  startEdge: AxisEdgeType\n  endEdge: AxisEdgeType\n  measureSize: (rect: DOMRect) => number\n}\n\nexport function Axis(\n  axis: AxisOptionType,\n  contentDirection: DirectionOptionType,\n): AxisType {\n  const scroll = axis === 'y' ? 'y' : 'x'\n  const cross = axis === 'y' ? 'x' : 'y'\n  const startEdge = getStartEdge()\n  const endEdge = getEndEdge()\n\n  function measureSize(rect: DOMRect): number {\n    const { width, height } = rect\n    return scroll === 'x' ? width : height\n  }\n\n  function getStartEdge(): AxisEdgeType {\n    if (scroll === 'y') return 'top'\n    return contentDirection === 'rtl' ? 'right' : 'left'\n  }\n\n  function getEndEdge(): AxisEdgeType {\n    if (scroll === 'y') return 'bottom'\n    return contentDirection === 'rtl' ? 'left' : 'right'\n  }\n\n  const self: AxisType = {\n    scroll,\n    cross,\n    startEdge,\n    endEdge,\n    measureSize,\n  }\n  return self\n}\n","export type LimitType = {\n  min: number\n  max: number\n  length: number\n  constrain: (n: number) => number\n  reachedAny: (n: number) => boolean\n  reachedMax: (n: number) => boolean\n  reachedMin: (n: number) => boolean\n  removeOffset: (n: number) => number\n}\n\nexport function Limit(min: number, max: number): LimitType {\n  const length = Math.abs(min - max)\n\n  function reachedMin(n: number): boolean {\n    return n < min\n  }\n\n  function reachedMax(n: number): boolean {\n    return n > max\n  }\n\n  function reachedAny(n: number): boolean {\n    return reachedMin(n) || reachedMax(n)\n  }\n\n  function constrain(n: number): number {\n    if (!reachedAny(n)) return n\n    return reachedMin(n) ? min : max\n  }\n\n  function removeOffset(n: number): number {\n    if (!length) return n\n    return n - length * Math.ceil((n - max) / length)\n  }\n\n  const self: LimitType = {\n    constrain,\n    length,\n    max,\n    min,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset,\n  }\n  return self\n}\n","import { Limit } from './Limit'\n\nexport type CounterType = {\n  get: () => number\n  set: (n: number) => CounterType\n  add: (n: number) => CounterType\n  clone: () => CounterType\n  min: number\n  max: number\n}\n\nexport function Counter(\n  max: number,\n  start: number,\n  loop: boolean,\n): CounterType {\n  const { min, constrain } = Limit(0, max)\n  const loopEnd = max + 1\n  let counter = withinLimit(start)\n\n  function withinLimit(n: number): number {\n    return !loop ? constrain(n) : Math.abs((loopEnd + n) % loopEnd)\n  }\n\n  function get(): number {\n    return counter\n  }\n\n  function set(n: number): CounterType {\n    counter = withinLimit(n)\n    return self\n  }\n\n  function add(n: number): CounterType {\n    return set(get() + n)\n  }\n\n  function clone(): CounterType {\n    return Counter(max, get(), loop)\n  }\n\n  const self: CounterType = {\n    add,\n    clone,\n    get,\n    set,\n    min,\n    max,\n  }\n  return self\n}\n","export type DirectionOptionType = 'ltr' | 'rtl'\n\nexport type DirectionType = {\n  applyTo: (n: number) => number\n}\n\nexport function Direction(direction: DirectionOptionType): DirectionType {\n  const sign = direction === 'rtl' ? -1 : 1\n\n  function applyTo(n: number): number {\n    return n * sign\n  }\n\n  const self: DirectionType = {\n    applyTo,\n  }\n  return self\n}\n","type EventRemoverType = () => void\ntype EventHandlerType = EventListener | EventListenerObject | null\ntype EventOptionsType = boolean | AddEventListenerOptions | undefined\n\nexport type EventStoreType = {\n  add: (\n    node: EventTarget,\n    type: keyof WindowEventMap,\n    handler: EventHandlerType,\n    options?: EventOptionsType,\n  ) => EventStoreType\n  removeAll: () => EventStoreType\n}\n\nexport function EventStore(): EventStoreType {\n  let listeners: EventRemoverType[] = []\n\n  function add(\n    node: EventTarget,\n    type: string,\n    handler: EventHandlerType,\n    options: EventOptionsType = false,\n  ): EventStoreType {\n    node.addEventListener(type, handler, options)\n    listeners.push(() => {\n      return node.removeEventListener(type, handler, options)\n    })\n    return self\n  }\n\n  function removeAll(): EventStoreType {\n    listeners = listeners.filter((remove) => remove())\n    return self\n  }\n\n  const self: EventStoreType = {\n    add,\n    removeAll,\n  }\n  return self\n}\n","export type Vector1DType = {\n  get: () => number\n  set: (v: Vector1DType | number) => Vector1DType\n  add: (v: Vector1DType | number) => Vector1DType\n  subtract: (v: Vector1DType | number) => Vector1DType\n  multiply: (n: number) => Vector1DType\n  divide: (n: number) => Vector1DType\n  normalize: () => Vector1DType\n}\n\nexport function Vector1D(value: number): Vector1DType {\n  let vector = value\n\n  function get(): number {\n    return vector\n  }\n\n  function set(n: Vector1DType | number): Vector1DType {\n    vector = readNumber(n)\n    return self\n  }\n\n  function add(n: Vector1DType | number): Vector1DType {\n    vector += readNumber(n)\n    return self\n  }\n\n  function subtract(n: Vector1DType | number): Vector1DType {\n    vector -= readNumber(n)\n    return self\n  }\n\n  function multiply(n: number): Vector1DType {\n    vector *= n\n    return self\n  }\n\n  function divide(n: number): Vector1DType {\n    vector /= n\n    return self\n  }\n\n  function normalize(): Vector1DType {\n    if (vector !== 0) divide(vector)\n    return self\n  }\n\n  function readNumber(n: Vector1DType | number): number {\n    return typeof n === 'number' ? n : n.get()\n  }\n\n  const self: Vector1DType = {\n    add,\n    divide,\n    get,\n    multiply,\n    normalize,\n    set,\n    subtract,\n  }\n  return self\n}\n","export function map(\n  value: number,\n  iStart: number,\n  iStop: number,\n  oStart: number,\n  oStop: number,\n): number {\n  return oStart + (oStop - oStart) * ((value - iStart) / (iStop - iStart))\n}\n\nexport function mathSign(n: number): number {\n  return !n ? 0 : n / Math.abs(n)\n}\n\nexport function deltaAbs(valueB: number, valueA: number): number {\n  return Math.abs(valueB - valueA)\n}\n\nexport function factorAbs(valueB: number, valueA: number): number {\n  if (valueB === 0 || valueA === 0) return 0\n  if (Math.abs(valueB) <= Math.abs(valueA)) return 0\n  const diff = deltaAbs(Math.abs(valueB), Math.abs(valueA))\n  return Math.abs(diff / valueB)\n}\n\nexport function roundToDecimals(decimalPoints: number): (n: number) => number {\n  const pow = Math.pow(10, decimalPoints)\n  return (n: number): number => Math.round(n * pow) / pow\n}\n\nexport function debounce(callback: () => void, time: number): () => void {\n  let timeout = 0\n  return (): void => {\n    window.clearTimeout(timeout)\n    timeout = window.setTimeout(callback, time) || 0\n  }\n}\n\nexport function groupArray<GenericType>(\n  array: GenericType[],\n  size: number,\n): GenericType[][] {\n  const groups = []\n  for (let i = 0; i < array.length; i += size) {\n    groups.push(array.slice(i, i + size))\n  }\n  return groups\n}\n\nexport function arrayKeys<GenericType>(array: GenericType[]): number[] {\n  return Object.keys(array).map(Number)\n}\n\nexport function arrayLast<GenericType>(array: GenericType[]): GenericType {\n  return array[lastIndex(array)]\n}\n\nexport function lastIndex<GenericType>(array: GenericType[]): number {\n  return Math.max(0, array.length - 1)\n}\n","import { AnimationType } from './Animation'\nimport { CounterType } from './Counter'\nimport { DirectionType } from './Direction'\nimport { DragTrackerType } from './DragTracker'\nimport { EventEmitterType } from './EventEmitter'\nimport { AxisType } from './Axis'\nimport { EventStore } from './EventStore'\nimport { ScrollBodyType } from './ScrollBody'\nimport { ScrollTargetType } from './ScrollTarget'\nimport { ScrollToType } from './ScrollTo'\nimport { Vector1D, Vector1DType } from './Vector1d'\nimport { deltaAbs, factorAbs, mathSign } from './utils'\n\nexport type DragHandlerType = {\n  addActivationEvents: () => void\n  clickAllowed: () => boolean\n  pointerDown: () => boolean\n  removeAllEvents: () => void\n}\n\nexport function DragHandler(\n  axis: AxisType,\n  direction: DirectionType,\n  rootNode: HTMLElement,\n  target: Vector1DType,\n  dragFree: boolean,\n  dragTracker: DragTrackerType,\n  location: Vector1DType,\n  animation: AnimationType,\n  scrollTo: ScrollToType,\n  scrollBody: ScrollBodyType,\n  scrollTarget: ScrollTargetType,\n  index: CounterType,\n  events: EventEmitterType,\n  loop: boolean,\n  skipSnaps: boolean,\n): DragHandlerType {\n  const { scroll: scrollAxis, cross: crossAxis } = axis\n  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA']\n  const startScroll = Vector1D(0)\n  const startCross = Vector1D(0)\n  const dragStartPoint = Vector1D(0)\n  const activationEvents = EventStore()\n  const interactionEvents = EventStore()\n  const snapForceBoost = { mouse: 2.5, touch: 3.5 }\n  const freeForceBoost = { mouse: 5, touch: 7 }\n  const baseSpeed = dragFree ? 5 : 16\n  const baseMass = 1\n  const dragThreshold = 20\n\n  let pointerIsDown = false\n  let preventScroll = false\n  let preventClick = false\n  let isMouse = false\n\n  function addActivationEvents(): void {\n    const node = rootNode\n    activationEvents\n      .add(node, 'touchmove', () => undefined)\n      .add(node, 'touchend', () => undefined)\n      .add(node, 'touchstart', down)\n      .add(node, 'mousedown', down)\n      .add(node, 'touchcancel', up)\n      .add(node, 'contextmenu', up)\n      .add(node, 'click', click)\n  }\n\n  function addInteractionEvents(): void {\n    const node = !isMouse ? rootNode : document\n    interactionEvents\n      .add(node, 'touchmove', move)\n      .add(node, 'touchend', up)\n      .add(node, 'mousemove', move)\n      .add(node, 'mouseup', up)\n  }\n\n  function removeAllEvents(): void {\n    activationEvents.removeAll()\n    interactionEvents.removeAll()\n  }\n\n  function isFocusNode(node: Element): boolean {\n    const name = node.nodeName || ''\n    return focusNodes.indexOf(name) > -1\n  }\n\n  function forceBoost(): number {\n    const boost = dragFree ? freeForceBoost : snapForceBoost\n    const type = isMouse ? 'mouse' : 'touch'\n    return boost[type]\n  }\n\n  function allowedForce(force: number, targetChanged: boolean): number {\n    const next = index.clone().add(mathSign(force) * -1)\n    const isEdge = next.get() === index.min || next.get() === index.max\n    const baseForce = scrollTarget.byDistance(force, !dragFree).distance\n\n    if (dragFree || Math.abs(force) < dragThreshold) return baseForce\n    if (!loop && isEdge) return baseForce * 0.6\n    if (skipSnaps && targetChanged) return baseForce * 0.5\n\n    return scrollTarget.byIndex(next.get(), 0).distance\n  }\n\n  function down(evt: Event): void {\n    isMouse = evt.type === 'mousedown'\n    if (isMouse && (evt as MouseEvent).button !== 0) return\n\n    const isMoving = deltaAbs(target.get(), location.get()) >= 2\n    const clearPreventClick = isMouse || !isMoving\n    const isNotFocusNode = !isFocusNode(evt.target as Element)\n    const preventDefault = isMoving || (isMouse && isNotFocusNode)\n\n    pointerIsDown = true\n    dragTracker.pointerDown(evt)\n    dragStartPoint.set(target)\n    target.set(location)\n    scrollBody.useBaseMass().useSpeed(80)\n    addInteractionEvents()\n    startScroll.set(dragTracker.readPoint(evt, scrollAxis))\n    startCross.set(dragTracker.readPoint(evt, crossAxis))\n    events.emit('pointerDown')\n\n    if (clearPreventClick) preventClick = false\n    if (preventDefault) evt.preventDefault()\n  }\n\n  function move(evt: Event): void {\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up()\n      const moveScroll = dragTracker.readPoint(evt, scrollAxis).get()\n      const moveCross = dragTracker.readPoint(evt, crossAxis).get()\n      const diffScroll = deltaAbs(moveScroll, startScroll.get())\n      const diffCross = deltaAbs(moveCross, startCross.get())\n      preventScroll = diffScroll > diffCross\n      if (!preventScroll && !preventClick) return up()\n    }\n    const diff = dragTracker.pointerMove(evt)\n    if (!preventClick && diff) preventClick = true\n    animation.start()\n    target.add(direction.applyTo(diff))\n    evt.preventDefault()\n  }\n\n  function up(): void {\n    const currentLocation = scrollTarget.byDistance(0, false)\n    const targetChanged = currentLocation.index !== index.get()\n    const rawForce = dragTracker.pointerUp() * forceBoost()\n    const force = allowedForce(direction.applyTo(rawForce), targetChanged)\n    const forceFactor = factorAbs(rawForce, force)\n    const isMoving = deltaAbs(target.get(), dragStartPoint.get()) >= 0.5\n    const isVigorous = targetChanged && forceFactor > 0.75\n    const isBelowThreshold = Math.abs(rawForce) < dragThreshold\n    const speed = isVigorous ? 10 : baseSpeed\n    const mass = isVigorous ? baseMass + 2.5 * forceFactor : baseMass\n\n    if (isMoving && !isMouse) preventClick = true\n    preventScroll = false\n    pointerIsDown = false\n    interactionEvents.removeAll()\n    scrollBody.useSpeed(isBelowThreshold ? 9 : speed).useMass(mass)\n    scrollTo.distance(force, !dragFree)\n    isMouse = false\n    events.emit('pointerUp')\n  }\n\n  function click(evt: Event): void {\n    if (preventClick) evt.preventDefault()\n  }\n\n  function clickAllowed(): boolean {\n    return !preventClick\n  }\n\n  function pointerDown(): boolean {\n    return pointerIsDown\n  }\n\n  const self: DragHandlerType = {\n    addActivationEvents,\n    clickAllowed,\n    pointerDown,\n    removeAllEvents,\n  }\n  return self\n}\n","import { AxisOptionType, AxisType } from './Axis'\nimport { PxToPercentType } from './PxToPercent'\nimport { Vector1D, Vector1DType } from './Vector1d'\n\nexport type DragTrackerType = {\n  pointerDown: (evt: Event) => number\n  pointerMove: (evt: Event) => number\n  pointerUp: () => number\n  readPoint: (evt: any, axis: AxisOptionType) => Vector1DType\n}\n\nexport function DragTracker(\n  axis: AxisType,\n  pxToPercent: PxToPercentType,\n): DragTrackerType {\n  const { scroll: scrollAxis } = axis\n  const coords = { x: 'clientX', y: 'clientY' }\n  const startDrag = Vector1D(0)\n  const diffDrag = Vector1D(0)\n  const lastDrag = Vector1D(0)\n  const pointValue = Vector1D(0)\n  const trackInterval = 10\n  const trackLength = 5\n  const trackTime = 100\n  let trackPoints: number[] = []\n  let lastMoveTime = new Date().getTime()\n  let isMouse = false\n\n  function readPoint(evt: any, type: AxisOptionType): Vector1DType {\n    isMouse = !evt.touches\n    const c = coords[type]\n    const value = isMouse ? evt[c] : evt.touches[0][c]\n    return pointValue.set(value)\n  }\n\n  function pointerDown(evt: Event): number {\n    const point = readPoint(evt, scrollAxis)\n    startDrag.set(point)\n    lastDrag.set(point)\n    return pxToPercent.measure(startDrag.get())\n  }\n\n  function pointerMove(evt: Event): number {\n    const point = readPoint(evt, scrollAxis)\n    const nowTime = new Date().getTime()\n    const diffTime = nowTime - lastMoveTime\n\n    if (diffTime >= trackInterval) {\n      if (diffTime >= trackTime) trackPoints = []\n      trackPoints.push(point.get())\n      lastMoveTime = nowTime\n    }\n\n    diffDrag.set(point).subtract(lastDrag)\n    lastDrag.set(point)\n    return pxToPercent.measure(diffDrag.get())\n  }\n\n  function pointerUp(): number {\n    const nowTime = new Date().getTime()\n    const diffTime = nowTime - lastMoveTime\n    const currentPoint = lastDrag.get()\n\n    const force = trackPoints\n      .slice(-trackLength)\n      .map((trackPoint) => currentPoint - trackPoint)\n      .sort((p1, p2) => (Math.abs(p1) < Math.abs(p2) ? 1 : -1))[0]\n\n    lastDrag.set(diffTime > trackTime || !force ? 0 : force)\n    trackPoints = []\n    return pxToPercent.measure(lastDrag.get())\n  }\n\n  const self: DragTrackerType = {\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint,\n  }\n  return self\n}\n","export type PxToPercentType = {\n  measure: (n: number) => number\n  totalPercent: number\n}\n\nexport function PxToPercent(viewInPx: number): PxToPercentType {\n  const totalPercent = 100\n\n  function measure(n: number): number {\n    if (viewInPx === 0) return 0\n    return (n / viewInPx) * totalPercent\n  }\n\n  const self: PxToPercentType = {\n    measure,\n    totalPercent,\n  }\n  return self\n}\n","import { map, roundToDecimals, mathSign } from './utils'\nimport { Vector1D, Vector1DType } from './Vector1d'\n\nexport type ScrollBodyType = {\n  direction: () => number\n  seek: (target: Vector1DType) => ScrollBodyType\n  settle: (target: Vector1DType) => boolean\n  update: () => void\n  useBaseMass: () => ScrollBodyType\n  useBaseSpeed: () => ScrollBodyType\n  useMass: (n: number) => ScrollBodyType\n  useSpeed: (n: number) => ScrollBodyType\n}\n\nexport function ScrollBody(\n  location: Vector1DType,\n  baseSpeed: number,\n  baseMass: number,\n): ScrollBodyType {\n  const roundToTwoDecimals = roundToDecimals(2)\n  const velocity = Vector1D(0)\n  const acceleration = Vector1D(0)\n  const attraction = Vector1D(0)\n\n  let attractionDirection = 0\n  let speed = baseSpeed\n  let mass = baseMass\n\n  function update(): void {\n    velocity.add(acceleration)\n    location.add(velocity)\n    acceleration.multiply(0)\n  }\n\n  function applyForce(force: Vector1DType): void {\n    force.divide(mass)\n    acceleration.add(force)\n  }\n\n  function seek(target: Vector1DType): ScrollBodyType {\n    attraction.set(target).subtract(location)\n    const magnitude = map(attraction.get(), 0, 100, 0, speed)\n    attractionDirection = mathSign(attraction.get())\n    attraction.normalize().multiply(magnitude).subtract(velocity)\n    applyForce(attraction)\n    return self\n  }\n\n  function settle(target: Vector1DType): boolean {\n    const diff = target.get() - location.get()\n    const hasSettled = !roundToTwoDecimals(diff)\n    if (hasSettled) location.set(target)\n    return hasSettled\n  }\n\n  function direction(): number {\n    return attractionDirection\n  }\n\n  function useBaseSpeed(): ScrollBodyType {\n    return useSpeed(baseSpeed)\n  }\n\n  function useBaseMass(): ScrollBodyType {\n    return useMass(baseMass)\n  }\n\n  function useSpeed(n: number): ScrollBodyType {\n    speed = n\n    return self\n  }\n\n  function useMass(n: number): ScrollBodyType {\n    mass = n\n    return self\n  }\n\n  const self: ScrollBodyType = {\n    direction,\n    seek,\n    settle,\n    update,\n    useBaseMass,\n    useBaseSpeed,\n    useMass,\n    useSpeed,\n  }\n  return self\n}\n","import { LimitType } from './Limit'\nimport { ScrollBodyType } from './ScrollBody'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollBoundsType = {\n  constrain: (pointerDown: boolean) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function ScrollBounds(\n  limit: LimitType,\n  location: Vector1DType,\n  target: Vector1DType,\n  scrollBody: ScrollBodyType,\n): ScrollBoundsType {\n  const pullBackThreshold = 10\n  let disabled = false\n\n  function shouldConstrain(): boolean {\n    if (disabled) return false\n    if (!limit.reachedAny(target.get())) return false\n    if (!limit.reachedAny(location.get())) return false\n    return true\n  }\n\n  function constrain(pointerDown: boolean): void {\n    if (!shouldConstrain()) return\n    const friction = pointerDown ? 0.7 : 0.45\n    const diffToTarget = target.get() - location.get()\n\n    target.subtract(diffToTarget * friction)\n\n    if (!pointerDown && Math.abs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()))\n      scrollBody.useSpeed(10).useMass(3)\n    }\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  const self: ScrollBoundsType = {\n    constrain,\n    toggleActive,\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollContainOptionType = '' | 'trimSnaps' | 'keepSnaps'\n\nexport type ScrollContainType = {\n  snapsContained: number[]\n}\n\nexport function ScrollContain(\n  viewSize: number,\n  contentSize: number,\n  snaps: number[],\n  snapsAligned: number[],\n  containScroll: ScrollContainOptionType,\n): ScrollContainType {\n  const scrollBounds = Limit(-contentSize + viewSize, snaps[0])\n  const snapsBounded = snapsAligned.map(scrollBounds.constrain)\n  const snapsContained = measureContained()\n\n  function findDuplicates(): LimitType {\n    const startSnap = snapsBounded[0]\n    const endSnap = arrayLast(snapsBounded)\n    const min = snapsBounded.lastIndexOf(startSnap)\n    const max = snapsBounded.indexOf(endSnap) + 1\n    return Limit(min, max)\n  }\n\n  function measureContained(): number[] {\n    if (contentSize <= viewSize) return [scrollBounds.max]\n    if (containScroll === 'keepSnaps') return snapsBounded\n    const { min, max } = findDuplicates()\n    return snapsBounded.slice(min, max)\n  }\n\n  const self: ScrollContainType = {\n    snapsContained,\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollLimitType = {\n  limit: LimitType\n}\n\nexport function ScrollLimit(\n  contentSize: number,\n  scrollSnaps: number[],\n  loop: boolean,\n): ScrollLimitType {\n  const limit = measureLimit()\n\n  function measureLimit(): LimitType {\n    const startSnap = scrollSnaps[0]\n    const endSnap = arrayLast(scrollSnaps)\n    const min = loop ? startSnap - contentSize : endSnap\n    const max = startSnap\n    return Limit(min, max)\n  }\n\n  const self: ScrollLimitType = {\n    limit,\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { PxToPercentType } from './PxToPercent'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollLooperType = {\n  loop: (direction: number) => void\n}\n\nexport function ScrollLooper(\n  contentSize: number,\n  pxToPercent: PxToPercentType,\n  limit: LimitType,\n  location: Vector1DType,\n  vectors: Vector1DType[],\n): ScrollLooperType {\n  const min = limit.min + pxToPercent.measure(0.1)\n  const max = limit.max + pxToPercent.measure(0.1)\n  const { reachedMin, reachedMax } = Limit(min, max)\n\n  function shouldLoop(direction: number): boolean {\n    if (direction === 1) return reachedMax(location.get())\n    if (direction === -1) return reachedMin(location.get())\n    return false\n  }\n\n  function loop(direction: number): void {\n    if (!shouldLoop(direction)) return\n\n    const loopDistance = contentSize * (direction * -1)\n    vectors.forEach((v) => v.add(loopDistance))\n  }\n\n  const self: ScrollLooperType = {\n    loop,\n  }\n  return self\n}\n","import { LimitType } from './Limit'\n\nexport type ScrollProgressType = {\n  get: (n: number) => number\n}\n\nexport function ScrollProgress(limit: LimitType): ScrollProgressType {\n  const { max, length: scrollLength } = limit\n\n  function get(n: number): number {\n    const currentLocation = n - max\n    return currentLocation / -scrollLength\n  }\n\n  const self: ScrollProgressType = {\n    get,\n  }\n  return self\n}\n","import { AlignmentType } from './Alignment'\nimport { AxisType } from './Axis'\nimport { PxToPercentType } from './PxToPercent'\nimport { arrayLast, groupArray } from './utils'\n\nexport type ScrollSnapType = {\n  snaps: number[]\n  snapsAligned: number[]\n}\n\nexport function ScrollSnap(\n  axis: AxisType,\n  alignment: AlignmentType,\n  pxToPercent: PxToPercentType,\n  containerRect: DOMRect,\n  slideRects: DOMRect[],\n  slidesToScroll: number,\n): ScrollSnapType {\n  const { startEdge, endEdge } = axis\n  const snaps = measureUnaligned()\n  const snapsAligned = measureAligned()\n\n  function measureSizes(): number[] {\n    return groupArray(slideRects, slidesToScroll)\n      .map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge])\n      .map(pxToPercent.measure)\n      .map(Math.abs)\n  }\n\n  function measureUnaligned(): number[] {\n    return slideRects\n      .map((rect) => containerRect[startEdge] - rect[startEdge])\n      .map(pxToPercent.measure)\n      .map((snap) => -Math.abs(snap))\n  }\n\n  function measureAligned(): number[] {\n    const groupedSnaps = groupArray(snaps, slidesToScroll).map((g) => g[0])\n    const alignments = measureSizes().map(alignment.measure)\n    return groupedSnaps.map((snap, index) => snap + alignments[index])\n  }\n\n  const self: ScrollSnapType = {\n    snaps,\n    snapsAligned,\n  }\n  return self\n}\n","import { LimitType } from './Limit'\nimport { Vector1DType } from './Vector1d'\n\nexport type TargetType = {\n  distance: number\n  index: number\n}\n\nexport type ScrollTargetType = {\n  byIndex: (target: number, direction: number) => TargetType\n  byDistance: (force: number, snap: boolean) => TargetType\n  shortcut: (target: number, direction: number) => number\n}\n\nexport function ScrollTarget(\n  loop: boolean,\n  scrollSnaps: number[],\n  contentSize: number,\n  limit: LimitType,\n  targetVector: Vector1DType,\n): ScrollTargetType {\n  const { reachedAny, removeOffset, constrain } = limit\n\n  function minDistance(d1: number, d2: number): number {\n    return Math.abs(d1) < Math.abs(d2) ? d1 : d2\n  }\n\n  function findTargetSnap(target: number): TargetType {\n    const distance = loop ? removeOffset(target) : constrain(target)\n    const ascDiffsToSnaps = scrollSnaps\n      .map((scrollSnap) => scrollSnap - distance)\n      .map((diffToSnap) => shortcut(diffToSnap, 0))\n      .map((diff, i) => ({ diff, index: i }))\n      .sort((d1, d2) => Math.abs(d1.diff) - Math.abs(d2.diff))\n\n    const { index } = ascDiffsToSnaps[0]\n    return { index, distance }\n  }\n\n  function shortcut(target: number, direction: number): number {\n    const t1 = target\n    const t2 = target + contentSize\n    const t3 = target - contentSize\n\n    if (!loop) return t1\n    if (!direction) return minDistance(minDistance(t1, t2), t3)\n\n    const shortest = minDistance(t1, direction === 1 ? t2 : t3)\n    return Math.abs(shortest) * direction\n  }\n\n  function byIndex(index: number, direction: number): TargetType {\n    const diffToSnap = scrollSnaps[index] - targetVector.get()\n    const distance = shortcut(diffToSnap, direction)\n    return { index, distance }\n  }\n\n  function byDistance(distance: number, snap: boolean): TargetType {\n    const target = targetVector.get() + distance\n    const { index, distance: targetSnapDistance } = findTargetSnap(target)\n    const reachedBound = !loop && reachedAny(target)\n\n    if (!snap || reachedBound) return { index, distance }\n\n    const diffToSnap = scrollSnaps[index] - targetSnapDistance\n    const snapDistance = distance + shortcut(diffToSnap, 0)\n\n    return { index, distance: snapDistance }\n  }\n\n  const self: ScrollTargetType = {\n    byDistance,\n    byIndex,\n    shortcut,\n  }\n  return self\n}\n","import { AnimationType } from './Animation'\nimport { CounterType } from './Counter'\nimport { EventEmitterType } from './EventEmitter'\nimport { ScrollTargetType, TargetType } from './ScrollTarget'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollToType = {\n  distance: (n: number, snap: boolean) => void\n  index: (n: number, direction: number) => void\n}\n\nexport function ScrollTo(\n  animation: AnimationType,\n  indexCurrent: CounterType,\n  indexPrevious: CounterType,\n  scrollTarget: ScrollTargetType,\n  targetVector: Vector1DType,\n  events: EventEmitterType,\n): ScrollToType {\n  function scrollTo(target: TargetType): void {\n    const distanceDiff = target.distance\n    const indexDiff = target.index !== indexCurrent.get()\n\n    if (distanceDiff) {\n      animation.start()\n      targetVector.add(distanceDiff)\n    }\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get())\n      indexCurrent.set(target.index)\n      events.emit('select')\n    }\n  }\n\n  function distance(n: number, snap: boolean): void {\n    const target = scrollTarget.byDistance(n, snap)\n    scrollTo(target)\n  }\n\n  function index(n: number, direction: number): void {\n    const targetIndex = indexCurrent.clone().set(n)\n    const target = scrollTarget.byIndex(targetIndex.get(), direction)\n    scrollTo(target)\n  }\n\n  const self: ScrollToType = {\n    distance,\n    index,\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { arrayKeys } from './utils'\nimport { SlidesInViewType } from './SlidesInView'\nimport { Vector1DType } from './Vector1d'\n\ntype EdgeType = 'start' | 'end'\n\ntype LoopPointType = {\n  point: number\n  location: number\n  index: number\n  getTarget: () => number\n}\n\nexport type SlideLooperType = {\n  canLoop: () => boolean\n  clear: () => void\n  loop: () => void\n  loopPoints: LoopPointType[]\n}\n\nexport function SlideLooper(\n  axis: AxisType,\n  viewSize: number,\n  contentSize: number,\n  slideSizesWithGaps: number[],\n  scrollSnaps: number[],\n  slidesInView: SlidesInViewType,\n  scrollLocation: Vector1DType,\n  slides: HTMLElement[],\n): SlideLooperType {\n  const ascItems = arrayKeys(slideSizesWithGaps)\n  const descItems = arrayKeys(slideSizesWithGaps).reverse()\n  const loopPoints = startPoints().concat(endPoints())\n\n  function removeSlideSizes(indexes: number[], from: number): number {\n    return indexes.reduce((a: number, i) => {\n      return a - slideSizesWithGaps[i]\n    }, from)\n  }\n\n  function slidesInGap(indexes: number[], gap: number): number[] {\n    return indexes.reduce((a: number[], i) => {\n      const remainingGap = removeSlideSizes(a, gap)\n      return remainingGap > 0 ? a.concat([i]) : a\n    }, [])\n  }\n\n  function findLoopPoints(indexes: number[], edge: EdgeType): LoopPointType[] {\n    const isStartEdge = edge === 'start'\n    const offset = isStartEdge ? -contentSize : contentSize\n    const slideBounds = slidesInView.findSlideBounds(offset)\n\n    return indexes.map((index) => {\n      const initial = isStartEdge ? 0 : -contentSize\n      const altered = isStartEdge ? contentSize : 0\n      const bounds = slideBounds.filter((b) => b.index === index)[0]\n      const point = bounds[isStartEdge ? 'end' : 'start']\n      const getTarget = (): number =>\n        scrollLocation.get() > point ? initial : altered\n      return { point, getTarget, index, location: -1 }\n    })\n  }\n\n  function startPoints(): LoopPointType[] {\n    const gap = scrollSnaps[0] - 1\n    const indexes = slidesInGap(descItems, gap)\n    return findLoopPoints(indexes, 'end')\n  }\n\n  function endPoints(): LoopPointType[] {\n    const gap = viewSize - scrollSnaps[0] - 1\n    const indexes = slidesInGap(ascItems, gap)\n    return findLoopPoints(indexes, 'start')\n  }\n\n  function canLoop(): boolean {\n    return loopPoints.every(({ index }) => {\n      const otherIndexes = ascItems.filter((i) => i !== index)\n      return removeSlideSizes(otherIndexes, viewSize) <= 0\n    })\n  }\n\n  function loop(): void {\n    loopPoints.forEach((loopPoint) => {\n      const { getTarget, location, index } = loopPoint\n      const target = getTarget()\n      if (target !== location) {\n        slides[index].style[axis.startEdge] = `${target}%`\n        loopPoint.location = target\n      }\n    })\n  }\n\n  function clear(): void {\n    loopPoints.forEach(({ index }) => {\n      slides[index].style[axis.startEdge] = ''\n    })\n  }\n\n  const self: SlideLooperType = {\n    canLoop,\n    clear,\n    loop,\n    loopPoints,\n  }\n  return self\n}\n","type SlideBoundType = {\n  start: number\n  end: number\n  index: number\n}\n\nexport type SlidesInViewType = {\n  check: (location: number) => number[]\n  findSlideBounds: (offset: number, threshold?: number) => SlideBoundType[]\n}\n\nexport function SlidesInView(\n  viewSize: number,\n  contentSize: number,\n  slideSizes: number[],\n  snaps: number[],\n  loop: boolean,\n  inViewThreshold: number,\n): SlidesInViewType {\n  const threshold = Math.min(Math.max(inViewThreshold, 0.01), 0.99)\n  const offsets = loop ? [0, contentSize, -contentSize] : [0]\n  const slideBounds = offsets.reduce((a: SlideBoundType[], offset) => {\n    return a.concat(findSlideBounds(offset, threshold))\n  }, [])\n\n  function findSlideBounds(\n    offset: number,\n    threshold?: number,\n  ): SlideBoundType[] {\n    const thresholds = slideSizes.map((s) => s * (threshold || 0))\n    return snaps.map((snap, index) => ({\n      start: snap - slideSizes[index] + thresholds[index] + offset,\n      end: snap + viewSize - thresholds[index] + offset,\n      index,\n    }))\n  }\n\n  function check(location: number): number[] {\n    return slideBounds.reduce((list: number[], slideBound) => {\n      const { index, start, end } = slideBound\n      const inList = list.indexOf(index) !== -1\n      const inView = start < location && end > location\n      return !inList && inView ? list.concat([index]) : list\n    }, [])\n  }\n\n  const self: SlidesInViewType = {\n    check,\n    findSlideBounds,\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { PxToPercentType } from './PxToPercent'\nimport { arrayLast, lastIndex } from './utils'\n\nexport type SlideSizesType = {\n  slideSizes: number[]\n  slideSizesWithGaps: number[]\n}\n\nexport function SlideSizes(\n  axis: AxisType,\n  pxToPercent: PxToPercentType,\n  slides: HTMLElement[],\n  slideRects: DOMRect[],\n  loop: boolean,\n): SlideSizesType {\n  const { measureSize, startEdge, endEdge } = axis\n  const sizesInPx = slideRects.map(measureSize)\n  const slideSizes = sizesInPx.map(pxToPercent.measure)\n  const slideSizesWithGaps = measureWithGaps()\n\n  function measureWithGaps(): number[] {\n    return slideRects\n      .map((rect, index, rects) => {\n        const isLast = index === lastIndex(rects)\n        const style = window.getComputedStyle(arrayLast(slides))\n        const endGap = parseFloat(style.getPropertyValue(`margin-${endEdge}`))\n        if (isLast) return sizesInPx[index] + (loop ? endGap : 0)\n        return rects[index + 1][startEdge] - rect[startEdge]\n      })\n      .map(pxToPercent.measure)\n      .map(Math.abs)\n  }\n\n  const self: SlideSizesType = {\n    slideSizes,\n    slideSizesWithGaps,\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { DirectionType } from './Direction'\nimport { Vector1DType } from './Vector1d'\n\nexport type TranslateType = {\n  clear: () => void\n  to: (vector: Vector1DType) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function Translate(\n  axis: AxisType,\n  direction: DirectionType,\n  container: HTMLElement,\n): TranslateType {\n  const containerStyle = container.style\n  const translate = axis.scroll === 'x' ? x : y\n  let disabled = false\n\n  function x(n: number): string {\n    return `translate3d(${n}%,0px,0px)`\n  }\n\n  function y(n: number): string {\n    return `translate3d(0px,${n}%,0px)`\n  }\n\n  function to(target: Vector1DType): void {\n    if (disabled) return\n    containerStyle.transform = translate(direction.applyTo(target.get()))\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  function clear(): void {\n    containerStyle.transform = ''\n  }\n\n  const self: TranslateType = {\n    clear,\n    to,\n    toggleActive,\n  }\n  return self\n}\n","import { Alignment } from './Alignment'\nimport { Animation, AnimationType } from './Animation'\nimport { Axis, AxisType } from './Axis'\nimport { Counter, CounterType } from './Counter'\nimport { Direction, DirectionType } from './Direction'\nimport { DragHandler, DragHandlerType } from './DragHandler'\nimport { DragTracker } from './DragTracker'\nimport { EventEmitterType } from './EventEmitter'\nimport { EventStore, EventStoreType } from './EventStore'\nimport { LimitType } from './Limit'\nimport { OptionsType } from './Options'\nimport { PxToPercent, PxToPercentType } from './PxToPercent'\nimport { ScrollBody, ScrollBodyType } from './ScrollBody'\nimport { ScrollBounds, ScrollBoundsType } from './ScrollBounds'\nimport { ScrollContain } from './ScrollContain'\nimport { ScrollLimit } from './ScrollLimit'\nimport { ScrollLooper, ScrollLooperType } from './ScrollLooper'\nimport { ScrollProgress, ScrollProgressType } from './ScrollProgress'\nimport { ScrollSnap } from './ScrollSnap'\nimport { ScrollTarget, ScrollTargetType } from './ScrollTarget'\nimport { ScrollTo, ScrollToType } from './ScrollTo'\nimport { SlideLooper, SlideLooperType } from './SlideLooper'\nimport { SlidesInView, SlidesInViewType } from './SlidesInView'\nimport { SlideSizes } from './SlideSizes'\nimport { Translate, TranslateType } from './Translate'\nimport { arrayKeys, arrayLast, lastIndex } from './utils'\nimport { Vector1D, Vector1DType } from './Vector1d'\n\nexport type Engine = {\n  axis: AxisType\n  direction: DirectionType\n  animation: AnimationType\n  scrollBounds: ScrollBoundsType\n  scrollLooper: ScrollLooperType\n  scrollProgress: ScrollProgressType\n  index: CounterType\n  indexPrevious: CounterType\n  limit: LimitType\n  location: Vector1DType\n  options: OptionsType\n  pxToPercent: PxToPercentType\n  scrollBody: ScrollBodyType\n  dragHandler: DragHandlerType\n  eventStore: EventStoreType\n  slideLooper: SlideLooperType\n  slidesInView: SlidesInViewType\n  target: Vector1DType\n  translate: TranslateType\n  scrollTo: ScrollToType\n  scrollTarget: ScrollTargetType\n  scrollSnaps: number[]\n  slideIndexes: number[]\n}\n\nexport function Engine(\n  root: HTMLElement,\n  container: HTMLElement,\n  slides: HTMLElement[],\n  options: OptionsType,\n  events: EventEmitterType,\n): Engine {\n  // Options\n  const {\n    align,\n    axis: scrollAxis,\n    direction: contentDirection,\n    startIndex,\n    inViewThreshold,\n    loop,\n    speed,\n    dragFree,\n    slidesToScroll,\n    skipSnaps,\n    containScroll,\n  } = options\n\n  // Measurements\n  const containerRect = container.getBoundingClientRect()\n  const slideRects = slides.map((slide) => slide.getBoundingClientRect())\n  const direction = Direction(contentDirection)\n  const axis = Axis(scrollAxis, contentDirection)\n  const pxToPercent = PxToPercent(axis.measureSize(containerRect))\n  const viewSize = pxToPercent.totalPercent\n  const alignment = Alignment(align, viewSize)\n  const { slideSizes, slideSizesWithGaps } = SlideSizes(\n    axis,\n    pxToPercent,\n    slides,\n    slideRects,\n    loop,\n  )\n  const { snaps, snapsAligned } = ScrollSnap(\n    axis,\n    alignment,\n    pxToPercent,\n    containerRect,\n    slideRects,\n    slidesToScroll,\n  )\n  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps)\n  const { snapsContained } = ScrollContain(\n    viewSize,\n    contentSize,\n    snaps,\n    snapsAligned,\n    containScroll,\n  )\n\n  const contain = !loop && containScroll !== ''\n  const scrollSnaps = contain ? snapsContained : snapsAligned\n  const { limit } = ScrollLimit(contentSize, scrollSnaps, loop)\n\n  // Indexes\n  const index = Counter(lastIndex(scrollSnaps), startIndex, loop)\n  const indexPrevious = index.clone()\n  const slideIndexes = arrayKeys(slides)\n\n  // Draw\n  const update = (): void => {\n    if (!loop) engine.scrollBounds.constrain(engine.dragHandler.pointerDown())\n    engine.scrollBody.seek(target).update()\n    const settled = engine.scrollBody.settle(target)\n\n    if (settled && !engine.dragHandler.pointerDown()) {\n      engine.animation.stop()\n      events.emit('settle')\n    }\n    if (!settled) {\n      events.emit('scroll')\n    }\n    if (loop) {\n      engine.scrollLooper.loop(engine.scrollBody.direction())\n      engine.slideLooper.loop()\n    }\n\n    engine.translate.to(location)\n    engine.animation.proceed()\n  }\n\n  // Shared\n  const animation = Animation(update)\n  const startLocation = scrollSnaps[index.get()]\n  const location = Vector1D(startLocation)\n  const target = Vector1D(startLocation)\n  const scrollBody = ScrollBody(location, speed, 1)\n  const scrollTarget = ScrollTarget(\n    loop,\n    scrollSnaps,\n    contentSize,\n    limit,\n    target,\n  )\n  const scrollTo = ScrollTo(\n    animation,\n    index,\n    indexPrevious,\n    scrollTarget,\n    target,\n    events,\n  )\n  const slidesInView = SlidesInView(\n    viewSize,\n    contentSize,\n    slideSizes,\n    snaps,\n    loop,\n    inViewThreshold,\n  )\n\n  // DragHandler\n  const dragHandler = DragHandler(\n    axis,\n    direction,\n    root,\n    target,\n    dragFree,\n    DragTracker(axis, pxToPercent),\n    location,\n    animation,\n    scrollTo,\n    scrollBody,\n    scrollTarget,\n    index,\n    events,\n    loop,\n    skipSnaps,\n  )\n\n  // Slider\n  const engine: Engine = {\n    animation,\n    axis,\n    direction,\n    dragHandler,\n    eventStore: EventStore(),\n    pxToPercent,\n    index,\n    indexPrevious,\n    limit,\n    location,\n    options,\n    scrollBody,\n    scrollBounds: ScrollBounds(limit, location, target, scrollBody),\n    scrollLooper: ScrollLooper(contentSize, pxToPercent, limit, location, [\n      location,\n      target,\n    ]),\n    scrollProgress: ScrollProgress(limit),\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideLooper: SlideLooper(\n      axis,\n      viewSize,\n      contentSize,\n      slideSizesWithGaps,\n      scrollSnaps,\n      slidesInView,\n      location,\n      slides,\n    ),\n    slidesInView,\n    slideIndexes,\n    target,\n    translate: Translate(axis, direction, container),\n  }\n  return engine\n}\n","type CallbackType = (evt: EmblaEventType) => void\ntype ListenersType = Partial<{ [key in EmblaEventType]: CallbackType[] }>\n\nexport type EmblaEventType =\n  | 'init'\n  | 'pointerDown'\n  | 'pointerUp'\n  | 'scroll'\n  | 'select'\n  | 'settle'\n  | 'destroy'\n  | 'reInit'\n  | 'resize'\n\nexport type EventEmitterType = {\n  emit: (evt: EmblaEventType) => EventEmitterType\n  on: (evt: EmblaEventType, cb: CallbackType) => EventEmitterType\n  off: (evt: EmblaEventType, cb: CallbackType) => EventEmitterType\n}\n\nexport function EventEmitter(): EventEmitterType {\n  const listeners: ListenersType = {}\n\n  function getListeners(evt: EmblaEventType): CallbackType[] {\n    return listeners[evt] || []\n  }\n\n  function emit(evt: EmblaEventType): EventEmitterType {\n    getListeners(evt).forEach((e) => e(evt))\n    return self\n  }\n\n  function on(evt: EmblaEventType, cb: CallbackType): EventEmitterType {\n    listeners[evt] = getListeners(evt).concat([cb])\n    return self\n  }\n\n  function off(evt: EmblaEventType, cb: CallbackType): EventEmitterType {\n    listeners[evt] = getListeners(evt).filter((e) => e !== cb)\n    return self\n  }\n\n  const self: EventEmitterType = {\n    emit,\n    off,\n    on,\n  }\n  return self\n}\n","import { AlignmentOptionType } from './Alignment'\nimport { AxisOptionType } from './Axis'\nimport { DirectionOptionType } from './Direction'\nimport { ScrollContainOptionType } from './ScrollContain'\n\nexport type OptionsType = {\n  align: AlignmentOptionType\n  axis: AxisOptionType\n  containScroll: ScrollContainOptionType\n  direction: DirectionOptionType\n  dragFree: boolean\n  draggable: boolean\n  inViewThreshold: number\n  loop: boolean\n  skipSnaps: boolean\n  slidesToScroll: number\n  speed: number\n  startIndex: number\n}\n\nexport const defaultOptions: OptionsType = {\n  align: 'center',\n  axis: 'x',\n  containScroll: '',\n  direction: 'ltr',\n  dragFree: false,\n  draggable: true,\n  inViewThreshold: 0,\n  loop: false,\n  skipSnaps: false,\n  slidesToScroll: 1,\n  speed: 10,\n  startIndex: 0,\n}\n\nexport type EmblaOptionsType = Partial<OptionsType>\n","import { EmblaOptionsType } from './Options'\n\nexport type OptionsPseudoType = {\n  get: () => EmblaOptionsType\n}\n\nexport function OptionsPseudo(node: HTMLElement): OptionsPseudoType {\n  const pseudoString = getComputedStyle(node, ':before').content\n\n  function get(): EmblaOptionsType {\n    try {\n      return JSON.parse(pseudoString.slice(1, -1).replace(/\\\\/g, ''))\n    } catch (error) {} // eslint-disable-line no-empty\n    return {}\n  }\n\n  const self: OptionsPseudoType = {\n    get,\n  }\n  return self\n}\n","import { Engine } from './Engine'\nimport { EventEmitter, EventEmitterType } from './EventEmitter'\nimport { defaultOptions, EmblaOptionsType } from './Options'\nimport { OptionsPseudo, OptionsPseudoType } from './OptionsPseudo'\nimport { debounce } from './utils'\n\nexport type EmblaNodesType = {\n  root: HTMLElement\n  container?: HTMLElement\n  slides?: HTMLElement[]\n}\n\ntype EmblaPluginOptionsType = {\n  [key: string]: unknown\n}\n\nexport type EmblaPluginType<\n  OptionsType extends EmblaPluginOptionsType = EmblaPluginOptionsType,\n> = {\n  name: string\n  options: OptionsType\n  init: (embla: EmblaCarouselType) => void\n  destroy: () => void\n  [key: string]: unknown\n}\n\nexport type EmblaCarouselType = {\n  canScrollNext: () => boolean\n  canScrollPrev: () => boolean\n  clickAllowed: () => boolean\n  containerNode: () => HTMLElement\n  internalEngine: () => Engine\n  destroy: () => void\n  off: EventEmitterType['off']\n  on: EventEmitterType['on']\n  previousScrollSnap: () => number\n  reInit: (options?: EmblaOptionsType, plugins?: EmblaPluginType[]) => void\n  rootNode: () => HTMLElement\n  scrollNext: (jump?: boolean) => void\n  scrollPrev: (jump?: boolean) => void\n  scrollProgress: () => number\n  scrollSnapList: () => number[]\n  scrollTo: (index: number, jump?: boolean) => void\n  selectedScrollSnap: () => number\n  slideNodes: () => HTMLElement[]\n  slidesInView: (target?: boolean) => number[]\n  slidesNotInView: (target?: boolean) => number[]\n}\n\nfunction EmblaCarousel(\n  nodes: HTMLElement | EmblaNodesType,\n  userOptions?: EmblaOptionsType,\n  userPlugins?: EmblaPluginType[],\n): EmblaCarouselType {\n  const events = EventEmitter()\n  const debouncedResize = debounce(resize, 500)\n  const reInit = reActivate\n  const { on, off } = events\n\n  let engine: Engine\n  let activated = false\n  let optionsBase = Object.assign({}, defaultOptions)\n  let options = Object.assign({}, optionsBase)\n  let optionsPseudo: OptionsPseudoType\n  let plugins: EmblaPluginType[]\n  let rootSize = 0\n  let root: HTMLElement\n  let container: HTMLElement\n  let slides: HTMLElement[]\n\n  function setupElements(): void {\n    const providedContainer = 'container' in nodes && nodes.container\n    const providedSlides = 'slides' in nodes && nodes.slides\n\n    root = 'root' in nodes ? nodes.root : nodes\n    container = providedContainer || <HTMLElement>root.children[0]\n    slides = providedSlides || [].slice.call(container.children)\n    optionsPseudo = OptionsPseudo(root)\n  }\n\n  function activate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[],\n  ): void {\n    setupElements()\n    optionsBase = Object.assign({}, optionsBase, withOptions)\n    options = Object.assign({}, optionsBase, optionsPseudo.get())\n    plugins = Object.assign([], withPlugins)\n    engine = Engine(root, container, slides, options, events)\n    engine.eventStore.add(window, 'resize', debouncedResize)\n    engine.translate.to(engine.location)\n    rootSize = engine.axis.measureSize(root.getBoundingClientRect())\n    plugins.forEach((plugin) => plugin.init(self))\n\n    if (options.loop) {\n      if (!engine.slideLooper.canLoop()) {\n        deActivate()\n        return activate({ loop: false }, withPlugins)\n      }\n      engine.slideLooper.loop()\n    }\n    if (options.draggable && container.offsetParent && slides.length) {\n      engine.dragHandler.addActivationEvents()\n    }\n    if (!activated) {\n      setTimeout(() => events.emit('init'), 0)\n      activated = true\n    }\n  }\n\n  function reActivate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[],\n  ): void {\n    if (!activated) return\n    const startIndex = selectedScrollSnap()\n    const newOptions = Object.assign({ startIndex }, withOptions)\n    deActivate()\n    activate(newOptions, withPlugins || plugins)\n    events.emit('reInit')\n  }\n\n  function deActivate(): void {\n    engine.dragHandler.removeAllEvents()\n    engine.animation.stop()\n    engine.eventStore.removeAll()\n    engine.translate.clear()\n    engine.slideLooper.clear()\n    plugins.forEach((plugin) => plugin.destroy())\n  }\n\n  function destroy(): void {\n    if (!activated) return\n    deActivate()\n    activated = false\n    events.emit('destroy')\n  }\n\n  function resize(): void {\n    if (!activated) return\n    const size = engine.axis.measureSize(root.getBoundingClientRect())\n    if (rootSize !== size) reActivate()\n    events.emit('resize')\n  }\n\n  function slidesInView(target?: boolean): number[] {\n    const location = engine[target ? 'target' : 'location'].get()\n    const type = options.loop ? 'removeOffset' : 'constrain'\n    return engine.slidesInView.check(engine.limit[type](location))\n  }\n\n  function slidesNotInView(target?: boolean): number[] {\n    const inView = slidesInView(target)\n    return engine.slideIndexes.filter((index) => inView.indexOf(index) === -1)\n  }\n\n  function scrollTo(index: number, jump?: boolean, direction?: number): void {\n    engine.scrollBody.useBaseMass().useSpeed(jump ? 100 : options.speed)\n    if (activated) engine.scrollTo.index(index, direction || 0)\n  }\n\n  function scrollNext(jump?: boolean): void {\n    const next = engine.index.clone().add(1)\n    scrollTo(next.get(), jump === true, -1)\n  }\n\n  function scrollPrev(jump?: boolean): void {\n    const prev = engine.index.clone().add(-1)\n    scrollTo(prev.get(), jump === true, 1)\n  }\n\n  function canScrollNext(): boolean {\n    const next = engine.index.clone().add(1)\n    return next.get() !== selectedScrollSnap()\n  }\n\n  function canScrollPrev(): boolean {\n    const prev = engine.index.clone().add(-1)\n    return prev.get() !== selectedScrollSnap()\n  }\n\n  function scrollSnapList(): number[] {\n    return engine.scrollSnaps.map(engine.scrollProgress.get)\n  }\n\n  function scrollProgress(): number {\n    return engine.scrollProgress.get(engine.location.get())\n  }\n\n  function selectedScrollSnap(): number {\n    return engine.index.get()\n  }\n\n  function previousScrollSnap(): number {\n    return engine.indexPrevious.get()\n  }\n\n  function clickAllowed(): boolean {\n    return engine.dragHandler.clickAllowed()\n  }\n\n  function internalEngine(): Engine {\n    return engine\n  }\n\n  function rootNode(): HTMLElement {\n    return root\n  }\n\n  function containerNode(): HTMLElement {\n    return container\n  }\n\n  function slideNodes(): HTMLElement[] {\n    return slides\n  }\n\n  const self: EmblaCarouselType = {\n    canScrollNext,\n    canScrollPrev,\n    clickAllowed,\n    containerNode,\n    internalEngine,\n    destroy,\n    off,\n    on,\n    previousScrollSnap,\n    reInit,\n    rootNode,\n    scrollNext,\n    scrollPrev,\n    scrollProgress,\n    scrollSnapList,\n    scrollTo,\n    selectedScrollSnap,\n    slideNodes,\n    slidesInView,\n    slidesNotInView,\n  }\n  activate(userOptions, userPlugins)\n  return self\n}\n\nexport default EmblaCarousel\n"]},"metadata":{},"sourceType":"module"}